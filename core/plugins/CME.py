"""A plugin to parse a CrackMapExex scan"""

import re
from core.Models.Ip import Ip
from core.Models.Port import Port
from core.plugins.plugin import Plugin


def getInfos(cme_file):
    r"""Read the given cme output file results and return a dictionnary with ips and a list of their open ports and infos.
        Args:
            cme_file:  the path to the .txt file generated by an cme.
        Returns:
        A tupe with 3 values:
            0. A List with dictionnaries inside.
                 Each dictionnary holds : "ip":str, "port":str, "hostname":str, "notes":str, "powned":bool
            1. a count of Powned found
            2. additional notes

    File example:

POWNED EXEMPLE:
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.3 Build 9600 (name:HAGRID) (domain:POUDLARD)
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[32m[+]\x1b[0m POUDLARD\Administrateur:Algo_LAB_2012* \x1b[1m\x1b[33m(Pwn3d!)\x1b[0m
\x1b[1m\x1b[34m[*]\x1b[0m KTHXBYE!

NOT POWNED:
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.11:445 DOBBY-PC        \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.1 Build 0 (name:DOBBY-PC) (domain:POUDLARD)
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.3 Build 9600 (name:HAGRID) (domain:POUDLARD)
\x1b[1m\x1b[34m[*]\x1b[0m KTHXBYE!

CONNECTED
^[[1m^[[34mCME^[[0m          10.0.0.86:445 ALGOSECURE-VM   ^[[1m^[[34m[*]^[[0m Windows 10.0 Build 18362 (name:ALGOSECURE-VM) (domain:ALGOSECURE-VM)
^[[1m^[[34mCME^[[0m          10.0.0.86:445 ALGOSECURE-VM   ^[[1m^[[32m[+]^[[0m ALGOSECURE-VM\algosecure:Alg123!*
"""
    retour = []
    regex_not_powned = re.compile(
        r"\S+CME\S+\s+(\S+):(\S+) (\S+)\s+\S+ ([^\(]+) \(name:([^\)]+)\) \(domain:([^\)]+)\)", re.MULTILINE)
    regex_powned = re.compile(
        r"\S+CME\S+\s+(\S+):(\S+) (\S+)\s+\S+ (\S+) \S+\(Pwn3d!\)", re.MULTILINE)
    regex_connected_not_powned = re.compile(
        r"\S+CME\S+\s+(\S+):(\S+) (\S+)\s+\S+\[\+\]\S+ (\S+)", re.MULTILINE)
    notes = ""
    countFound = 0
    countPwn = 0
    kthxbyeFound = False
    cmeFound = False
    for line in cme_file:
        # Search ip in file
        if "\x1b[1m\x1b[34mCME\x1b[0m" in line:
            cmeFound = True
        if "KTHXBYE!" in line:
            kthxbyeFound = True
        toAdd = {}
        not_powned_infos = re.search(regex_not_powned, line)
        if not_powned_infos is not None:
            toAdd["ip"] = not_powned_infos.group(1)
            toAdd["port"] = not_powned_infos.group(2)
            toAdd["hostname"] = not_powned_infos.group(3)
            toAdd["OS"] = not_powned_infos.group(4)
            toAdd["machine_name"] = not_powned_infos.group(5)
            toAdd["domain"] = not_powned_infos.group(6)
            countFound += 1
        else:
            powned_infos = re.search(regex_powned, line)
            if powned_infos is not None:
                toAdd["ip"] = powned_infos.group(1)
                toAdd["port"] = powned_infos.group(2)
                toAdd["hostname"] = powned_infos.group(3)
                toAdd["creds"] = powned_infos.group(4)
                toAdd["powned"] = True
                countPwn += 1
            else:
                connected_infos = re.search(regex_connected_not_powned, line)
                if connected_infos is not None:
                    toAdd["ip"] = connected_infos.group(1)
                    toAdd["port"] = connected_infos.group(2)
                    toAdd["hostname"] = connected_infos.group(3)
                    toAdd["creds"] = connected_infos.group(4)
                    toAdd["powned"] = False
        if toAdd.keys():
            retour.append(toAdd)
    if not kthxbyeFound:
        return None, None, None
    if not cmeFound:
        return None, None, None
    notes = "Pwn3d count : " + \
        str(countPwn)+"\nHost found : "+str(countFound) + "\n" + notes
    return retour, countPwn, notes


def editScopeIPs(hostsInfos):
    """
    Add all the ips and theirs ports found after parsing the file to the scope object in database.
    Args:
        hostsInfos: the dictionnary with ips as keys and a list of dictionnary containing ports informations as value.
    """
    # Check if any ip has been found.
    if hostsInfos is not None:
        for infos in hostsInfos:
            tags = []
            if infos.get("powned", False):
                tags.append("P0wned!")
            infosToAdd = {}
            OS = infos.get("OS", "")
            if OS != "":
                infosToAdd["OS"] = OS
            creds = infos.get("creds", "")
            if creds != "":
                infosToAdd["creds"] = creds
            powned = infos.get("powned", False)
            if powned:
                infosToAdd["powned"] = "True"
            ip_m = Ip().initialize(str(infos["ip"]))
            res, iid = ip_m.addInDb()
            if not res:
                ip_m = Ip.fetchObject({"_id": iid})
            infosToAdd["hostname"] = list(set(ip_m.infos.get(
                "hostname", []) + [infos["hostname"]]))
            ip_m.notes = "hostname:" + \
                infos["hostname"] + "\n"+infos.get("OS", "")
            ip_m.tags = tags
            ip_m.update()
            port_m = Port().initialize(str(infos["ip"]), str(
                infos["port"]), "tcp", "netbios-ssn")
            res, iid = port_m.addInDb()
            if not res:
                port_m = Port.fetchObject({"_id": iid})
            port_m.updateInfos(infosToAdd)
            port_m.tags = tags
            port_m.update()


class CME(Plugin):
    """Inherits Plugin
    A plugin to parse a crackmapexec scan"""

    def getFileOutputArg(self):
        """Returns the command line paramater giving the output file
        Returns:
            string
        """
        return " > "

    def getFileOutputExt(self):
        """Returns the expected file extension for this command result file
        Returns:
            string
        """
        return ".log.txt"

    def getFileOutputPath(self, commandExecuted):
        """Returns the output file path given in the executed command using getFileOutputArg
        Args:
            commandExecuted: the command that was executed with an output file inside.
        Returns:
            string: the path to file created
        """
        return commandExecuted.split(self.getFileOutputArg())[-1].strip().split(" ")[0]

    def checkReturnCode(self, returncode):
        """Check if the command was executed successfully using the final exit code.
        Args:
            returncode: the exit code of the command executed.
        Returns:
            bool: True if successful returncode, False otherwise.
        """
        return returncode == 0

    def Parse(self, file_opened, **_kwargs):
        """
        Parse a opened file to extract information
       
        Args:
            file_opened: the open file
            _kwargs: not used
        Returns:
            a tuple with 4 values (All set to None if Parsing wrong file): 
                0. notes: notes to be inserted in tool giving direct info to pentester
                1. tags: a list of tags to be added to tool 
                2. lvl: the level of the command executed to assign to given targets
                3. targets: a list of composed keys allowing retrieve/insert from/into database targerted objects.
        """
        notes = ""
        tags = []
        hostsInfos, countPwnd, notes = getInfos(file_opened)
        if countPwnd is not None:
            if int(countPwnd) > 0:
                tags = ["P0wned!"]
        if hostsInfos is None:
            return None, None, None, None
        editScopeIPs(hostsInfos)
        return notes, tags, "wave", {"wave": None}
