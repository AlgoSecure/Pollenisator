<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>Pollenisator.core.Application.Treeviews.CalendarTreeview API documentation</title>
<meta name="description" content="CalendarTreeview class
Ttk treeview class with added functions." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Pollenisator.core.Application.Treeviews.CalendarTreeview</code></h1>
</header>
<section id="section-intro">
<p>CalendarTreeview class
Ttk treeview class with added functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;CalendarTreeview class
Ttk treeview class with added functions.
&#34;&#34;&#34;
import tkinter as tk
from bson.objectid import ObjectId
from core.Components.mongo import MongoCalendar
from core.Components.Settings import Settings
from core.Models.Interval import Interval
from core.Models.Ip import Ip
from core.Models.Port import Port
from core.Models.Scope import Scope
from core.Models.Tool import Tool
from core.Models.Wave import Wave
from core.Models.Defect import Defect
from core.Views.IntervalView import IntervalView
from core.Views.IpView import IpView
from core.Views.MultipleIpView import MultipleIpView
from core.Views.MultipleScopeView import MultipleScopeView
from core.Views.MultiSelectionView import MultiSelectionView
from core.Views.PortView import PortView
from core.Views.ScopeView import ScopeView
from core.Views.ToolView import ToolView
from core.Views.WaveView import WaveView
from core.Views.DefectView import DefectView
from core.Controllers.WaveController import WaveController
from core.Controllers.PortController import PortController
from core.Controllers.ScopeController import ScopeController
from core.Controllers.ToolController import ToolController
from core.Controllers.DefectController import DefectController
from core.Controllers.IpController import IpController
from core.Controllers.IntervalController import IntervalController
from core.Application.Dialogs.ChildDialogProgress import ChildDialogProgress
from core.Application.Dialogs.ChildDialogInfo import ChildDialogInfo
from core.Application.Dialogs.ChildDialogCustomCommand import ChildDialogCustomCommand
from core.Application.Dialogs.ChildDialogExportSelection import ChildDialogExportSelection
from core.Application.Treeviews.PollenisatorTreeview import PollenisatorTreeview


class CalendarTreeview(PollenisatorTreeview):
    &#34;&#34;&#34;Inherit PollenisatorTreeview.
    Ttk treeview class with added functions to handle the main view objects.
    &#34;&#34;&#34;

    def __init__(self, appli, parentFrame):
        &#34;&#34;&#34;
        Args:
            appli: a reference to the main Application object.
            parentFrame: the parent tkinter window object.
        &#34;&#34;&#34;
        super().__init__(appli, parentFrame)
        self._hidden = []  # Hidden objects references
        self.tagsMenu = None  # Menu bar for tag changing
        self.tagsVars = None  # list of tag values
        self.contextualMenu = None  #  contextual menu to open on right click
        self.waves_node = None  # the wave parent node on the treeview
        self.ips_node = None  # the IPs parent node on the treeview
        self.openedViewFrameId = None  # id of opened object in the view frame.

    def initUI(self):
        &#34;&#34;&#34;Initialize the user interface widgets and binds them.&#34;&#34;&#34;
        self._initContextualsMenus()
        self.heading(&#39;#0&#39;, text=&#39;Object&#39;, anchor=tk.W)
        self.column(&#39;#0&#39;, stretch=tk.YES, minwidth=300, width=300)
        self.bind(&#34;&lt;Button-3&gt;&#34;, self.doPopup)
        self.bind(&#34;&lt;Button-2&gt;&#34;, self.doPopupTag)
        #self.bind(&#34;&lt;Return&gt;&#34;, self.onTreeviewSelect)
        #self.bind(&#34;&lt;Button-1&gt;&#34;, self.onTreeviewSelect)
        self.bind(&#34;&lt;&lt;TreeviewSelect&gt;&gt;&#34;, self.onTreeviewSelect)
        self.bind(&#39;&lt;Delete&gt;&#39;, self.deleteSelected)
        self.bind(&#39;h&#39;, self.hideSelection)
        self.bind(&#34;&lt;Shift-Down&gt;&#34;, self.openNextSameTypeNode)
        self.bind(&#34;&lt;Shift-Up&gt;&#34;, self.openPrevSameTypeNode)

    def getRows(self, startNode=&#39;&#39;):
        &#34;&#34;&#34;Returns all child nodes of the given startNode iid as a list.
        Args:
            - startNode: node to recursively get children. Default to &#39;&#39; which is rhe treeview root.
        Returns:
            - List of all children iid of given node.
        &#34;&#34;&#34;
        myRows = []
        children = self.get_children(startNode)
        for child in children:
            myRows.append(child)
            myRows += self.getRows(child)
        return myRows

    def openPrevSameTypeNode(self, _event):
        &#34;&#34;&#34;Open the first node of the same type above the currently selected object on the tree view.
        Args:
            - _event: not used but mandatory
        Return:
            return the string &#34;break&#34; to stop processing the event
        &#34;&#34;&#34;
        fromNode = self.selection()
        if fromNode:
            fromNode = fromNode[0]
            rows = self.getRows()
            pos = rows.index(fromNode)
            if pos-1 &gt; 0:
                view_o = self.getViewFromId(fromNode)
                classToFind = view_o.__class__
                for row_nth in range(pos-1, -1, -1):
                    row = rows[row_nth]
                    cmp_view_o = self.getViewFromId(row)
                    if classToFind == cmp_view_o.__class__:
                        self.see(row)
                        self.focus(row)
                        self.selection_set(row)
                        return &#34;break&#34;
        return &#34;break&#34;

    def openNextSameTypeNode(self, _event):
        &#34;&#34;&#34;Open the first node of the same type below the currently selected object on the tree view.
        Args:
            - _event: not used but mandatory
        Return:
            return the string &#34;break&#34; to stop processing the event
        &#34;&#34;&#34;
        fromNode = self.selection()
        if fromNode:
            fromNode = fromNode[0]
            rows = self.getRows()
            pos = rows.index(fromNode)
            if pos+1 &lt; len(rows):
                view_o = self.getViewFromId(fromNode)
                classToFind = view_o.__class__
                for row in rows[pos+1:]:
                    cmp_view_o = self.getViewFromId(row)
                    if classToFind == cmp_view_o.__class__:
                        self.see(row)
                        self.focus(row)
                        self.selection_set(row)
                        return &#34;break&#34;
        return &#34;break&#34;

    def doPopup(self, event):
        &#34;&#34;&#34;Called when a right click is received by the tree view.
        Open the contextual menu at the clicked position.
        Args:
            - event: sent automatically though an event on treeview
        &#34;&#34;&#34;
        if self.contextualMenu is not None:
            self.popupFocusOut()
        self._initContextualsMenus()
        self.contextualMenu.selection = self.identify(
            &#34;item&#34;, event.x, event.y)
        view = self.getViewFromId(str(self.contextualMenu.selection))
        if view is None:
            self.contextualMenu.entryconfig(4, state=tk.DISABLED)
        else:
            self.contextualMenu.entryconfig(4, state=tk.ACTIVE)
        if self.appli.searchMode:
            self.contextualMenu.add_command(
                label=&#34;Show in full tree&#34;, command=self.showInTreeview)
        super().doPopup(event)

    def doPopupTag(self, event):
        &#34;&#34;&#34;Called when a middle click is received by the tree view.
        Open the tag menu at the clicked position.
        Args:
            - event: sent automatically though an event on treeview
        &#34;&#34;&#34;
        self.tagsMenu.selection = self.identify(
            &#34;item&#34;, event.x, event.y)
        # display the popup menu
        try:
            self.tagsMenu.post(event.x_root, event.y_root)
        finally:
            # make sure to release the grab (Tk 8.0a1 only)
            self.tagsMenu.grab_release()
        self.tagsMenu.focus_set()
        self.tagsMenu.bind(&#39;&lt;FocusOut&gt;&#39;, self.popupFocusOutTag)

    def popupFocusOutTag(self, _=None):
        &#34;&#34;&#34;Called when the tag contextual menu is unfocused.
        Close the tag contextual menu.
        &#34;&#34;&#34;
        self.tagsMenu.unpost()

    def showInTreeview(self, _=None):
        &#34;&#34;&#34;Unfilter the treeview and focus the node stored in the contextualMenu.selection variable0
        Also select it.
        &#34;&#34;&#34;
        node = str(self.contextualMenu.selection)
        self.unfilter()
        self.see(node)
        self.focus(node)
        self.selection_set(node)

    def tagClicked(self, name):
        &#34;&#34;&#34;Callback for an event. If the function was called directly it would not work.
        Args:
            - name: the tag name clicked
        &#34;&#34;&#34;
        return lambda : self.setTagFromMenubar(name)

    def _initContextualsMenus(self):
        &#34;&#34;&#34;
        Create the contextual menu
        &#34;&#34;&#34;
        self.contextualMenu = tk.Menu(self.parentFrame, tearoff=0, background=&#39;#A8CF4D&#39;,
                                      foreground=&#39;white&#39;, activebackground=&#39;#A8CF4D&#39;, activeforeground=&#39;white&#39;)
        self.contextualMenu.add_command(
            label=&#34;Custom command&#34;, command=self.customCommand)
        self.contextualMenu.add_command(
            label=&#34;Export selection&#34;, command=self.exportSelection)
        self.tagsMenu = tk.Menu(self.parentFrame, tearoff=0, background=&#39;#A8CF4D&#39;,
                                foreground=&#39;white&#39;, activebackground=&#39;#A8CF4D&#39;, activeforeground=&#39;white&#39;)
        tags = Settings.getTags()
        listOfLambdas = [self.tagClicked(tag) for tag in list(tags.keys())]
        for i,val in enumerate(tags):
            self.tagsMenu.add_command(
                label=val, command=listOfLambdas[i])
        self.contextualMenu.add_command(
            label=&#34;Sort children&#34;, command=self.sort)
        self.contextualMenu.add_command(
            label=&#34;Expand&#34;, command=self.expand)
        self.contextualMenu.add_command(
            label=&#34;Collapse&#34;, command=self.collapse)
        self.contextualMenu.add_command(
            label=&#34;Hide&#34;, command=self.hideAndUpdate)
        self.contextualMenu.add_command(
            label=&#34;Unhide children&#34;, command=self.unhide)
        self.contextualMenu.add_command(
            label=&#34;Close&#34;, command=self.closeMenu)

    def setTagFromMenubar(self, name):
        &#34;&#34;&#34;
        Change the tags of every selected object in the treeview to the one selected in the tag contextual menu.
        Args:
            - name: the tag name clicked
        &#34;&#34;&#34;
        for selected in self.selection():
            view_o = self.getViewFromId(selected)
            view_o.controller.setTags([name])

    def closeMenu(self, _event=None):
        &#34;&#34;&#34;
        Close the contextual menu. Does nothing, just an empty callback
        Args:
            - _event: not used but mandatory
        &#34;&#34;&#34;
        # Do nothing and close
        return

    def notify(self, db, collection, iid, action, _parent):
        &#34;&#34;&#34;
        Callback for the observer implemented in mongo.py.
        Each time an object is inserted, updated or deleted the standard way, this function will be called.

        Args:
            collection: the collection that has been modified
            iid: the mongo ObjectId _id that was modified/inserted/deleted
            action: string &#34;update&#34; or &#34;insert&#34; or &#34;delete&#34;. It was the action performed on the iid
            _parent: Not used. the mongo ObjectId of the parent. Only if action in an insert. Not used anymore
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        if not mongoInstance.hasACalendarOpen():
            return
        if mongoInstance.calendarName != db:
            return
        # Delete
        if action == &#34;delete&#34;:
            if collection == &#34;defects&#34;:
                view = self.getViewFromId(str(iid))
                if view is not None:
                    view.beforeDelete()
                    self.appli.statusbar.notify([],view.controller.getTags())
            try:
                self.delete(ObjectId(iid))
            except tk.TclError:
                pass  # item was not inserted in the treeview

        # Insert
        if action == &#34;insert&#34;:
            view = None
            res = mongoInstance.find(collection, {&#34;_id&#34;: ObjectId(iid)}, False)
            if collection == &#34;tools&#34;:
                view = ToolView(self, self.appli.viewframe,
                                self.appli, ToolController(Tool(res)))
            elif collection == &#34;waves&#34;:
                view = WaveView(self, self.appli.viewframe,
                                self.appli, WaveController(Wave(res)))
            elif collection == &#34;scopes&#34;:
                view = ScopeView(self, self.appli.viewframe,
                                 self.appli, ScopeController(Scope(res)))
            elif collection == &#34;ports&#34;:
                view = PortView(self, self.appli.viewframe,
                                self.appli, PortController(Port(res)))
            elif collection == &#34;ips&#34;:
                view = IpView(self, self.appli.viewframe,
                              self.appli, IpController(Ip(res)))
            elif collection == &#34;intervals&#34;:
                view = IntervalView(self, self.appli.viewframe,
                                    self.appli, IntervalController(Interval(res)))
            elif collection == &#34;defects&#34;:
                view = DefectView(self, self.appli.viewframe,
                                self.appli, DefectController(Defect(res)))
            try:
                if view is not None:
                    view.addInTreeview()
                    view.insertReceived()
                    self.appli.statusbar.notify(view.controller.getTags())
            except tk.TclError:
                pass

        if action == &#34;update&#34;:
            try:
                view = self.getViewFromId(str(iid))
                if view is not None:
                    oldTags = self.item(str(iid))[&#34;tags&#34;]
                    view.controller.actualize()
                    self.appli.statusbar.notify(view.controller.getTags(), oldTags)
                    self.item(str(iid), text=str(
                        view.controller.getModelRepr()), image=view.getIcon())
            except tk.TclError:
                if view is not None:
                    view.addInTreeview()
            if str(self.appli.openedViewFrameId) == str(iid):
                for widget in self.appli.viewframe.winfo_children():
                    widget.destroy()
                view.openModifyWindow()
            if view is not None:
                view.updateReceived()
        self.appli.statusbar.update()

    def exportSelection(self, _event=None):
        &#34;&#34;&#34;
        Popup a window to help a user to export some data from treeview.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        values = set()
        for selected in self.selection():
            view_o = self.getViewFromId(selected)
            if view_o is not None:
                data = view_o.controller.getData()
                for key in data.keys():
                    if key == &#34;infos&#34;:
                        for info_keys in data[&#34;infos&#34;]:
                            values.add(&#34;infos.&#34;+info_keys)
                    else:
                        values.add(key)
        dialog = ChildDialogExportSelection(self, values)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, list):
            fields_to_export = dialog.rvalue
            f = tk.filedialog.asksaveasfilename(defaultextension=&#34;.csv&#34;)
            if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
                return
            csv_filename = str(f)
            with open(csv_filename, &#39;w&#39;) as f:
                f.write(&#34;, &#34;.join(fields_to_export)+&#34;\n&#34;)
                for selected in self.selection():
                    view_o = self.getViewFromId(selected)
                    if view_o is not None:
                        line = []
                        modelData = view_o.controller.getData()
                        for field in fields_to_export:
                            if field.startswith(&#34;infos.&#34;):
                                line.append(
                                    str(modelData.get(&#34;infos&#34;, {}).get(field[6:], &#34;&#34;)))
                            else:
                                line.append(str(modelData.get(field, &#34;&#34;)))
                        f.write(&#34;, &#34;.join(line)+&#34;\n&#34;)
            dialog = ChildDialogInfo(
                self, &#34;Export completed&#34;, &#34;Your export just finished. You can find it here : &#34;+csv_filename)
        self.wait_window(dialog.app)

    def customCommand(self, _event=None):
        &#34;&#34;&#34;
        Ask the user for a custom tool to launch and which parser it will use.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        workers = self.appli.scanManager.monitor.getWorkerList()
        workers.append(&#34;localhost&#34;)
        dialog = ChildDialogCustomCommand(
                    self, workers, &#34;localhost&#34;)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, tuple):
            commName = dialog.rvalue[0]
            commArgs = dialog.rvalue[1]
            parser = dialog.rvalue[2]
            worker = dialog.rvalue[3]
        for selected in self.selection():
            view_o = self.getViewFromId(selected)
            if view_o is not None:
                lvl = &#34;network&#34; if isinstance(view_o, ScopeView) else None
                lvl = &#34;wave&#34; if isinstance(view_o, WaveView) else lvl
                lvl = &#34;ip&#34; if isinstance(view_o, IpView) else lvl
                lvl = &#34;port&#34; if isinstance(view_o, PortView) else lvl
                if lvl is not None:
                    inst = view_o.controller.getData()
                    wave = inst.get(&#34;wave&#34;, &#34;Custom commands&#34;)
                    if wave == &#34;Custom commands&#34;:
                        Wave().initialize(&#34;Custom commands&#34;).addInDb()
                    tool = Tool()
                    tool.initialize(commName, wave, inst.get(&#34;scope&#34;, &#34;&#34;), inst.get(&#34;ip&#34;, None), inst.get(&#34;port&#34;, None), inst.get(
                        &#34;proto&#34;, None), lvl, commArgs, dated=&#34;None&#34;, datef=&#34;None&#34;, scanner_ip=&#34;None&#34;, notes=&#34;Arguments: &#34;+commArgs)
                    tool.addInDb()
                    if tool is None:
                        print(&#34;Tool already existing.&#34;)
                        return
                    self.appli.scanManager.monitor.launchTask(
                        mongoInstance.calendarName, tool, parser, False, worker)

    def onTreeviewSelect(self, event=None):
        &#34;&#34;&#34;Called when a line is selected on the treeview
        Open the selected object view on the view frame.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        selection = self.selection()
        if len(selection) == 1:
            item = super().onTreeviewSelect(event)
            if isinstance(item, str):
                mongoInstance = MongoCalendar.getInstance()
                self.saveState(mongoInstance.calendarName)
                if str(item) == &#34;waves&#34;:
                    objView = WaveView(self, self.appli.viewframe,
                                    self.appli, WaveController(Wave()))
                    objView.openInsertWindow()
                elif str(item) == &#34;ips&#34;:
                    objView = MultipleIpView(
                        self, self.appli.viewframe, self.appli, IpController(Ip()))
                    objView.openInsertWindow()
                elif &#34;intervals&#34; in str(item):
                    wave = Wave.fetchObject(
                        {&#34;_id&#34;: ObjectId(IntervalView.treeviewListIdToDb(item))})
                    objView = IntervalView(self, self.appli.viewframe, self.appli, IntervalController(
                        Interval().initialize(wave.wave)))
                    objView.openInsertWindow()
                elif &#34;scopes&#34; in str(item):
                    wave = Wave.fetchObject(
                        {&#34;_id&#34;: ObjectId(ScopeView.treeviewListIdToDb(item))})
                    objView = MultipleScopeView(
                        self, self.appli.viewframe, self.appli, ScopeController(Scope().initialize(wave.wave)))
                    objView.openInsertWindow()
            else:
                self.openModifyWindowOf(item)
        elif len(selection) &gt; 1:
            # Multi select:
            multiView = MultiSelectionView(self, self.appli.viewframe, self.appli)
            for widget in self.appli.viewframe.winfo_children():
                widget.destroy()
            multiView.form.clear()
            multiView.openModifyWindow()

    def load(self, searchModel=None):
        &#34;&#34;&#34;
        Load the treeview with database information
        Args:
            searchModel: (DEPRECATED) a search object default to None
        &#34;&#34;&#34;
        for widget in self.appli.viewframe.winfo_children():
            widget.destroy()
        # Reattach hidden as get_children won&#39;t get them otherwise
        hidden = sorted(self._hidden, key=lambda x: len(x[0]))
        for hide in hidden:
            try:
                self.reattach(hide[0], hide[1], 0)
            except tk.TclError:
                pass
        # Clear the tree
        mongoInstance = MongoCalendar.getInstance()
        self.heading(&#34;#0&#34;, text=mongoInstance.calendarName)
        self.delete(*self.get_children())
        self._hidden = []
        if searchModel is None:
            self._load()
        elif searchModel.query == &#34;&#34;:
            self._load()
        else:
            viewsFound = searchModel.getViews(
                self, self.appli.viewframe, self.appli)
            for viewFound in viewsFound:
                viewFound.addInTreeview(&#39;&#39;, False)
        self.loadState(mongoInstance.calendarName)

    def refresh(self):
        &#34;&#34;&#34;Alias to load function&#34;&#34;&#34;
        self.load()

    def _load(self):
        &#34;&#34;&#34;
        Load the treeview with database information
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        dialog = ChildDialogProgress(self.appli, &#34;Loading &#34;+str(
            mongoInstance.calendarName), &#34;Opening &#34;+str(mongoInstance.calendarName) + &#34;. Please wait for a few seconds.&#34;, 200, &#34;determinate&#34;)
        step = 0
        dialog.show(100)
        nbObjects = mongoInstance.find(&#34;waves&#34;).count()
        nbObjects += mongoInstance.find(&#34;scopes&#34;).count()
        nbObjects += mongoInstance.find(&#34;intervals&#34;).count()
        nbObjects += mongoInstance.find(&#34;scopes&#34;).count()
        nbObjects += mongoInstance.find(&#34;ips&#34;).count()
        nbObjects += mongoInstance.find(&#34;ports&#34;).count()
        nbObjects += mongoInstance.find(&#34;tools&#34;).count()
        onePercentNbObject = nbObjects//100 if nbObjects &gt; 100 else 1
        nbObjectTreated = 0
        for child in self.get_children():
            self.delete(child)
        self._hidden = []
        self._detached = []
        self.waves_node = self.insert(&#34;&#34;, &#34;end&#34;, str(
            &#34;waves&#34;), text=&#34;Waves&#34;, image=WaveView.getClassIcon())
        # Loading every category separatly is faster than recursivly.
        # This is due to cursor.next function calls in pymongo
        # Adding wave objects
        waves = Wave.fetchObjects({})
        for wave in waves:
            wave_o = WaveController(wave)
            wave_vw = WaveView(self, self.appli.viewframe, self.appli, wave_o)
            wave_vw.addInTreeview(self.waves_node, False)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        scopes = Scope.fetchObjects({})
        for scope in scopes:
            scope_o = ScopeController(scope)
            scope_vw = ScopeView(self, self.appli.viewframe, self.appli, scope_o)
            scope_vw.addInTreeview(None, False)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        intervals = Interval.fetchObjects({})
        for interval in intervals:
            interval_o = IntervalController(interval)
            interval_vw = IntervalView(self, self.appli.viewframe, self.appli, interval_o)
            interval_vw.addInTreeview(None, False)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding ip objects
        self.ips_node = self.insert(&#34;&#34;, &#34;end&#34;, str(
            &#34;ips&#34;), text=&#34;IPs&#34;, image=IpView.getClassIcon())
        ips = Ip.fetchObjects({})
        for ip in ips:
            ip_o = IpController(ip)
            ip_vw = IpView(self, self.appli.viewframe, self.appli, ip_o)
            ip_vw.addInTreeview(None, False)
            self.appli.statusbar.notify(ip_vw.controller.getTags())
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding port objects
        ports = Port.fetchObjects({})
        for port in ports:
            port_o = PortController(port)
            port_vw = PortView(self, self.appli.viewframe, self.appli, port_o)
            port_vw.addInTreeview(None, False)
            self.appli.statusbar.notify(port_vw.controller.getTags())
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding defect objects
        defects = Defect.fetchObjects({&#34;ip&#34;:{&#34;$ne&#34;:&#34;&#34;}})
        for defect in defects:
            defect_o = DefectController(defect)
            defect_vw = DefectView(
                self, self.appli.viewframe, self.appli, defect_o)
            defect_vw.addInTreeview(None)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding tool objects
        tools = Tool.fetchObjects({})
        for tool in tools:
            tool_o = ToolController(tool)
            tool_vw = ToolView(self, self.appli.viewframe, self.appli, tool_o)
            tool_vw.addInTreeview(None, False)
            self.appli.statusbar.notify(tool_vw.controller.getTags())
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        self.sort(self.ips_node)
        self.appli.statusbar.update()
        dialog.destroy()

    def openModifyWindowOf(self, dbId):
        &#34;&#34;&#34;
        Retrieve the View of the database id given and open the modifying form for its model.
        Args:
            dbId: the Mongo Id to open the modification form on.
        &#34;&#34;&#34;
        # self.resetTags()
        objView = self.getViewFromId(str(dbId))
        if objView is not None:
            for widget in self.appli.viewframe.winfo_children():
                widget.destroy()
            objView.form.clear()
            self.openedViewFrameId = str(dbId)
            objView.openModifyWindow()

    def unhide(self, node=None):
        &#34;&#34;&#34;Unhide children of given node.
        Args:
            - node: the node which we want to unhide the children.
                    If this value is None, use the contextualMenu.selection value
                    Default to None.
        &#34;&#34;&#34;
        nodeToUnhideChildren = str(
            self.contextualMenu.selection) if node is None else node
        hidden = sorted(self._hidden, key=lambda x: len(x[0]))
        for hidden in self._hidden:
            itemId = hidden[0]
            parentId = &#39;&#39; if hidden[1] is None else hidden[1]
            if str(parentId) == str(nodeToUnhideChildren):
                view_o = self.getViewFromId(str(itemId))
                if view_o is not None:
                    view_o.controller.delTag(&#34;hidden&#34;)
                try:
                    self.reattach(itemId, parentId, 0)
                except tk.TclError:
                    pass # Le noeud a ete supprime entre temps

    def hideAndUpdate(self):
        &#34;&#34;&#34;Hide object with contextualMenu attached in the treeview and store this effect in its tags.&#34;&#34;&#34;
        self.hide(None, True)

    def hideSelection(self, _event=None):
        &#34;&#34;&#34; Hide selected objects in the treeview and store this effect in their tags.&#34;&#34;&#34;
        selectedNodes = self.selection()
        for node in selectedNodes:
            self.hide(node, True)

    def hide(self, node=None, updateTags=False):
        &#34;&#34;&#34;Hide given node object in the treeview and can store this effect in its tag.
        Args:
            - node: node to hide. If none is given, the contextualMenu.selection value will be used.
                    Default to None.
            - updateTags: mark the object as hidden in its tags. Default to False
        &#34;&#34;&#34;
        nodeToHide = str(
            self.contextualMenu.selection) if node is None else node
        view_o = self.getViewFromId(nodeToHide)
        if view_o is not None:
            if updateTags:
                view_o.controller.addTag(&#34;hidden&#34;)
            self._hidden.append([nodeToHide, view_o.getParent()])
            self.detach(nodeToHide)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview"><code class="flex name class">
<span>class <span class="ident">CalendarTreeview</span></span>
<span>(</span><span>appli, parentFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Inherit PollenisatorTreeview.
Ttk treeview class with added functions to handle the main view objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>appli</code></strong></dt>
<dd>a reference to the main Application object.</dd>
<dt><strong><code>parentFrame</code></strong></dt>
<dd>the parent tkinter window object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalendarTreeview(PollenisatorTreeview):
    &#34;&#34;&#34;Inherit PollenisatorTreeview.
    Ttk treeview class with added functions to handle the main view objects.
    &#34;&#34;&#34;

    def __init__(self, appli, parentFrame):
        &#34;&#34;&#34;
        Args:
            appli: a reference to the main Application object.
            parentFrame: the parent tkinter window object.
        &#34;&#34;&#34;
        super().__init__(appli, parentFrame)
        self._hidden = []  # Hidden objects references
        self.tagsMenu = None  # Menu bar for tag changing
        self.tagsVars = None  # list of tag values
        self.contextualMenu = None  #  contextual menu to open on right click
        self.waves_node = None  # the wave parent node on the treeview
        self.ips_node = None  # the IPs parent node on the treeview
        self.openedViewFrameId = None  # id of opened object in the view frame.

    def initUI(self):
        &#34;&#34;&#34;Initialize the user interface widgets and binds them.&#34;&#34;&#34;
        self._initContextualsMenus()
        self.heading(&#39;#0&#39;, text=&#39;Object&#39;, anchor=tk.W)
        self.column(&#39;#0&#39;, stretch=tk.YES, minwidth=300, width=300)
        self.bind(&#34;&lt;Button-3&gt;&#34;, self.doPopup)
        self.bind(&#34;&lt;Button-2&gt;&#34;, self.doPopupTag)
        #self.bind(&#34;&lt;Return&gt;&#34;, self.onTreeviewSelect)
        #self.bind(&#34;&lt;Button-1&gt;&#34;, self.onTreeviewSelect)
        self.bind(&#34;&lt;&lt;TreeviewSelect&gt;&gt;&#34;, self.onTreeviewSelect)
        self.bind(&#39;&lt;Delete&gt;&#39;, self.deleteSelected)
        self.bind(&#39;h&#39;, self.hideSelection)
        self.bind(&#34;&lt;Shift-Down&gt;&#34;, self.openNextSameTypeNode)
        self.bind(&#34;&lt;Shift-Up&gt;&#34;, self.openPrevSameTypeNode)

    def getRows(self, startNode=&#39;&#39;):
        &#34;&#34;&#34;Returns all child nodes of the given startNode iid as a list.
        Args:
            - startNode: node to recursively get children. Default to &#39;&#39; which is rhe treeview root.
        Returns:
            - List of all children iid of given node.
        &#34;&#34;&#34;
        myRows = []
        children = self.get_children(startNode)
        for child in children:
            myRows.append(child)
            myRows += self.getRows(child)
        return myRows

    def openPrevSameTypeNode(self, _event):
        &#34;&#34;&#34;Open the first node of the same type above the currently selected object on the tree view.
        Args:
            - _event: not used but mandatory
        Return:
            return the string &#34;break&#34; to stop processing the event
        &#34;&#34;&#34;
        fromNode = self.selection()
        if fromNode:
            fromNode = fromNode[0]
            rows = self.getRows()
            pos = rows.index(fromNode)
            if pos-1 &gt; 0:
                view_o = self.getViewFromId(fromNode)
                classToFind = view_o.__class__
                for row_nth in range(pos-1, -1, -1):
                    row = rows[row_nth]
                    cmp_view_o = self.getViewFromId(row)
                    if classToFind == cmp_view_o.__class__:
                        self.see(row)
                        self.focus(row)
                        self.selection_set(row)
                        return &#34;break&#34;
        return &#34;break&#34;

    def openNextSameTypeNode(self, _event):
        &#34;&#34;&#34;Open the first node of the same type below the currently selected object on the tree view.
        Args:
            - _event: not used but mandatory
        Return:
            return the string &#34;break&#34; to stop processing the event
        &#34;&#34;&#34;
        fromNode = self.selection()
        if fromNode:
            fromNode = fromNode[0]
            rows = self.getRows()
            pos = rows.index(fromNode)
            if pos+1 &lt; len(rows):
                view_o = self.getViewFromId(fromNode)
                classToFind = view_o.__class__
                for row in rows[pos+1:]:
                    cmp_view_o = self.getViewFromId(row)
                    if classToFind == cmp_view_o.__class__:
                        self.see(row)
                        self.focus(row)
                        self.selection_set(row)
                        return &#34;break&#34;
        return &#34;break&#34;

    def doPopup(self, event):
        &#34;&#34;&#34;Called when a right click is received by the tree view.
        Open the contextual menu at the clicked position.
        Args:
            - event: sent automatically though an event on treeview
        &#34;&#34;&#34;
        if self.contextualMenu is not None:
            self.popupFocusOut()
        self._initContextualsMenus()
        self.contextualMenu.selection = self.identify(
            &#34;item&#34;, event.x, event.y)
        view = self.getViewFromId(str(self.contextualMenu.selection))
        if view is None:
            self.contextualMenu.entryconfig(4, state=tk.DISABLED)
        else:
            self.contextualMenu.entryconfig(4, state=tk.ACTIVE)
        if self.appli.searchMode:
            self.contextualMenu.add_command(
                label=&#34;Show in full tree&#34;, command=self.showInTreeview)
        super().doPopup(event)

    def doPopupTag(self, event):
        &#34;&#34;&#34;Called when a middle click is received by the tree view.
        Open the tag menu at the clicked position.
        Args:
            - event: sent automatically though an event on treeview
        &#34;&#34;&#34;
        self.tagsMenu.selection = self.identify(
            &#34;item&#34;, event.x, event.y)
        # display the popup menu
        try:
            self.tagsMenu.post(event.x_root, event.y_root)
        finally:
            # make sure to release the grab (Tk 8.0a1 only)
            self.tagsMenu.grab_release()
        self.tagsMenu.focus_set()
        self.tagsMenu.bind(&#39;&lt;FocusOut&gt;&#39;, self.popupFocusOutTag)

    def popupFocusOutTag(self, _=None):
        &#34;&#34;&#34;Called when the tag contextual menu is unfocused.
        Close the tag contextual menu.
        &#34;&#34;&#34;
        self.tagsMenu.unpost()

    def showInTreeview(self, _=None):
        &#34;&#34;&#34;Unfilter the treeview and focus the node stored in the contextualMenu.selection variable0
        Also select it.
        &#34;&#34;&#34;
        node = str(self.contextualMenu.selection)
        self.unfilter()
        self.see(node)
        self.focus(node)
        self.selection_set(node)

    def tagClicked(self, name):
        &#34;&#34;&#34;Callback for an event. If the function was called directly it would not work.
        Args:
            - name: the tag name clicked
        &#34;&#34;&#34;
        return lambda : self.setTagFromMenubar(name)

    def _initContextualsMenus(self):
        &#34;&#34;&#34;
        Create the contextual menu
        &#34;&#34;&#34;
        self.contextualMenu = tk.Menu(self.parentFrame, tearoff=0, background=&#39;#A8CF4D&#39;,
                                      foreground=&#39;white&#39;, activebackground=&#39;#A8CF4D&#39;, activeforeground=&#39;white&#39;)
        self.contextualMenu.add_command(
            label=&#34;Custom command&#34;, command=self.customCommand)
        self.contextualMenu.add_command(
            label=&#34;Export selection&#34;, command=self.exportSelection)
        self.tagsMenu = tk.Menu(self.parentFrame, tearoff=0, background=&#39;#A8CF4D&#39;,
                                foreground=&#39;white&#39;, activebackground=&#39;#A8CF4D&#39;, activeforeground=&#39;white&#39;)
        tags = Settings.getTags()
        listOfLambdas = [self.tagClicked(tag) for tag in list(tags.keys())]
        for i,val in enumerate(tags):
            self.tagsMenu.add_command(
                label=val, command=listOfLambdas[i])
        self.contextualMenu.add_command(
            label=&#34;Sort children&#34;, command=self.sort)
        self.contextualMenu.add_command(
            label=&#34;Expand&#34;, command=self.expand)
        self.contextualMenu.add_command(
            label=&#34;Collapse&#34;, command=self.collapse)
        self.contextualMenu.add_command(
            label=&#34;Hide&#34;, command=self.hideAndUpdate)
        self.contextualMenu.add_command(
            label=&#34;Unhide children&#34;, command=self.unhide)
        self.contextualMenu.add_command(
            label=&#34;Close&#34;, command=self.closeMenu)

    def setTagFromMenubar(self, name):
        &#34;&#34;&#34;
        Change the tags of every selected object in the treeview to the one selected in the tag contextual menu.
        Args:
            - name: the tag name clicked
        &#34;&#34;&#34;
        for selected in self.selection():
            view_o = self.getViewFromId(selected)
            view_o.controller.setTags([name])

    def closeMenu(self, _event=None):
        &#34;&#34;&#34;
        Close the contextual menu. Does nothing, just an empty callback
        Args:
            - _event: not used but mandatory
        &#34;&#34;&#34;
        # Do nothing and close
        return

    def notify(self, db, collection, iid, action, _parent):
        &#34;&#34;&#34;
        Callback for the observer implemented in mongo.py.
        Each time an object is inserted, updated or deleted the standard way, this function will be called.

        Args:
            collection: the collection that has been modified
            iid: the mongo ObjectId _id that was modified/inserted/deleted
            action: string &#34;update&#34; or &#34;insert&#34; or &#34;delete&#34;. It was the action performed on the iid
            _parent: Not used. the mongo ObjectId of the parent. Only if action in an insert. Not used anymore
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        if not mongoInstance.hasACalendarOpen():
            return
        if mongoInstance.calendarName != db:
            return
        # Delete
        if action == &#34;delete&#34;:
            if collection == &#34;defects&#34;:
                view = self.getViewFromId(str(iid))
                if view is not None:
                    view.beforeDelete()
                    self.appli.statusbar.notify([],view.controller.getTags())
            try:
                self.delete(ObjectId(iid))
            except tk.TclError:
                pass  # item was not inserted in the treeview

        # Insert
        if action == &#34;insert&#34;:
            view = None
            res = mongoInstance.find(collection, {&#34;_id&#34;: ObjectId(iid)}, False)
            if collection == &#34;tools&#34;:
                view = ToolView(self, self.appli.viewframe,
                                self.appli, ToolController(Tool(res)))
            elif collection == &#34;waves&#34;:
                view = WaveView(self, self.appli.viewframe,
                                self.appli, WaveController(Wave(res)))
            elif collection == &#34;scopes&#34;:
                view = ScopeView(self, self.appli.viewframe,
                                 self.appli, ScopeController(Scope(res)))
            elif collection == &#34;ports&#34;:
                view = PortView(self, self.appli.viewframe,
                                self.appli, PortController(Port(res)))
            elif collection == &#34;ips&#34;:
                view = IpView(self, self.appli.viewframe,
                              self.appli, IpController(Ip(res)))
            elif collection == &#34;intervals&#34;:
                view = IntervalView(self, self.appli.viewframe,
                                    self.appli, IntervalController(Interval(res)))
            elif collection == &#34;defects&#34;:
                view = DefectView(self, self.appli.viewframe,
                                self.appli, DefectController(Defect(res)))
            try:
                if view is not None:
                    view.addInTreeview()
                    view.insertReceived()
                    self.appli.statusbar.notify(view.controller.getTags())
            except tk.TclError:
                pass

        if action == &#34;update&#34;:
            try:
                view = self.getViewFromId(str(iid))
                if view is not None:
                    oldTags = self.item(str(iid))[&#34;tags&#34;]
                    view.controller.actualize()
                    self.appli.statusbar.notify(view.controller.getTags(), oldTags)
                    self.item(str(iid), text=str(
                        view.controller.getModelRepr()), image=view.getIcon())
            except tk.TclError:
                if view is not None:
                    view.addInTreeview()
            if str(self.appli.openedViewFrameId) == str(iid):
                for widget in self.appli.viewframe.winfo_children():
                    widget.destroy()
                view.openModifyWindow()
            if view is not None:
                view.updateReceived()
        self.appli.statusbar.update()

    def exportSelection(self, _event=None):
        &#34;&#34;&#34;
        Popup a window to help a user to export some data from treeview.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        values = set()
        for selected in self.selection():
            view_o = self.getViewFromId(selected)
            if view_o is not None:
                data = view_o.controller.getData()
                for key in data.keys():
                    if key == &#34;infos&#34;:
                        for info_keys in data[&#34;infos&#34;]:
                            values.add(&#34;infos.&#34;+info_keys)
                    else:
                        values.add(key)
        dialog = ChildDialogExportSelection(self, values)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, list):
            fields_to_export = dialog.rvalue
            f = tk.filedialog.asksaveasfilename(defaultextension=&#34;.csv&#34;)
            if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
                return
            csv_filename = str(f)
            with open(csv_filename, &#39;w&#39;) as f:
                f.write(&#34;, &#34;.join(fields_to_export)+&#34;\n&#34;)
                for selected in self.selection():
                    view_o = self.getViewFromId(selected)
                    if view_o is not None:
                        line = []
                        modelData = view_o.controller.getData()
                        for field in fields_to_export:
                            if field.startswith(&#34;infos.&#34;):
                                line.append(
                                    str(modelData.get(&#34;infos&#34;, {}).get(field[6:], &#34;&#34;)))
                            else:
                                line.append(str(modelData.get(field, &#34;&#34;)))
                        f.write(&#34;, &#34;.join(line)+&#34;\n&#34;)
            dialog = ChildDialogInfo(
                self, &#34;Export completed&#34;, &#34;Your export just finished. You can find it here : &#34;+csv_filename)
        self.wait_window(dialog.app)

    def customCommand(self, _event=None):
        &#34;&#34;&#34;
        Ask the user for a custom tool to launch and which parser it will use.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        workers = self.appli.scanManager.monitor.getWorkerList()
        workers.append(&#34;localhost&#34;)
        dialog = ChildDialogCustomCommand(
                    self, workers, &#34;localhost&#34;)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, tuple):
            commName = dialog.rvalue[0]
            commArgs = dialog.rvalue[1]
            parser = dialog.rvalue[2]
            worker = dialog.rvalue[3]
        for selected in self.selection():
            view_o = self.getViewFromId(selected)
            if view_o is not None:
                lvl = &#34;network&#34; if isinstance(view_o, ScopeView) else None
                lvl = &#34;wave&#34; if isinstance(view_o, WaveView) else lvl
                lvl = &#34;ip&#34; if isinstance(view_o, IpView) else lvl
                lvl = &#34;port&#34; if isinstance(view_o, PortView) else lvl
                if lvl is not None:
                    inst = view_o.controller.getData()
                    wave = inst.get(&#34;wave&#34;, &#34;Custom commands&#34;)
                    if wave == &#34;Custom commands&#34;:
                        Wave().initialize(&#34;Custom commands&#34;).addInDb()
                    tool = Tool()
                    tool.initialize(commName, wave, inst.get(&#34;scope&#34;, &#34;&#34;), inst.get(&#34;ip&#34;, None), inst.get(&#34;port&#34;, None), inst.get(
                        &#34;proto&#34;, None), lvl, commArgs, dated=&#34;None&#34;, datef=&#34;None&#34;, scanner_ip=&#34;None&#34;, notes=&#34;Arguments: &#34;+commArgs)
                    tool.addInDb()
                    if tool is None:
                        print(&#34;Tool already existing.&#34;)
                        return
                    self.appli.scanManager.monitor.launchTask(
                        mongoInstance.calendarName, tool, parser, False, worker)

    def onTreeviewSelect(self, event=None):
        &#34;&#34;&#34;Called when a line is selected on the treeview
        Open the selected object view on the view frame.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        selection = self.selection()
        if len(selection) == 1:
            item = super().onTreeviewSelect(event)
            if isinstance(item, str):
                mongoInstance = MongoCalendar.getInstance()
                self.saveState(mongoInstance.calendarName)
                if str(item) == &#34;waves&#34;:
                    objView = WaveView(self, self.appli.viewframe,
                                    self.appli, WaveController(Wave()))
                    objView.openInsertWindow()
                elif str(item) == &#34;ips&#34;:
                    objView = MultipleIpView(
                        self, self.appli.viewframe, self.appli, IpController(Ip()))
                    objView.openInsertWindow()
                elif &#34;intervals&#34; in str(item):
                    wave = Wave.fetchObject(
                        {&#34;_id&#34;: ObjectId(IntervalView.treeviewListIdToDb(item))})
                    objView = IntervalView(self, self.appli.viewframe, self.appli, IntervalController(
                        Interval().initialize(wave.wave)))
                    objView.openInsertWindow()
                elif &#34;scopes&#34; in str(item):
                    wave = Wave.fetchObject(
                        {&#34;_id&#34;: ObjectId(ScopeView.treeviewListIdToDb(item))})
                    objView = MultipleScopeView(
                        self, self.appli.viewframe, self.appli, ScopeController(Scope().initialize(wave.wave)))
                    objView.openInsertWindow()
            else:
                self.openModifyWindowOf(item)
        elif len(selection) &gt; 1:
            # Multi select:
            multiView = MultiSelectionView(self, self.appli.viewframe, self.appli)
            for widget in self.appli.viewframe.winfo_children():
                widget.destroy()
            multiView.form.clear()
            multiView.openModifyWindow()

    def load(self, searchModel=None):
        &#34;&#34;&#34;
        Load the treeview with database information
        Args:
            searchModel: (DEPRECATED) a search object default to None
        &#34;&#34;&#34;
        for widget in self.appli.viewframe.winfo_children():
            widget.destroy()
        # Reattach hidden as get_children won&#39;t get them otherwise
        hidden = sorted(self._hidden, key=lambda x: len(x[0]))
        for hide in hidden:
            try:
                self.reattach(hide[0], hide[1], 0)
            except tk.TclError:
                pass
        # Clear the tree
        mongoInstance = MongoCalendar.getInstance()
        self.heading(&#34;#0&#34;, text=mongoInstance.calendarName)
        self.delete(*self.get_children())
        self._hidden = []
        if searchModel is None:
            self._load()
        elif searchModel.query == &#34;&#34;:
            self._load()
        else:
            viewsFound = searchModel.getViews(
                self, self.appli.viewframe, self.appli)
            for viewFound in viewsFound:
                viewFound.addInTreeview(&#39;&#39;, False)
        self.loadState(mongoInstance.calendarName)

    def refresh(self):
        &#34;&#34;&#34;Alias to load function&#34;&#34;&#34;
        self.load()

    def _load(self):
        &#34;&#34;&#34;
        Load the treeview with database information
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        dialog = ChildDialogProgress(self.appli, &#34;Loading &#34;+str(
            mongoInstance.calendarName), &#34;Opening &#34;+str(mongoInstance.calendarName) + &#34;. Please wait for a few seconds.&#34;, 200, &#34;determinate&#34;)
        step = 0
        dialog.show(100)
        nbObjects = mongoInstance.find(&#34;waves&#34;).count()
        nbObjects += mongoInstance.find(&#34;scopes&#34;).count()
        nbObjects += mongoInstance.find(&#34;intervals&#34;).count()
        nbObjects += mongoInstance.find(&#34;scopes&#34;).count()
        nbObjects += mongoInstance.find(&#34;ips&#34;).count()
        nbObjects += mongoInstance.find(&#34;ports&#34;).count()
        nbObjects += mongoInstance.find(&#34;tools&#34;).count()
        onePercentNbObject = nbObjects//100 if nbObjects &gt; 100 else 1
        nbObjectTreated = 0
        for child in self.get_children():
            self.delete(child)
        self._hidden = []
        self._detached = []
        self.waves_node = self.insert(&#34;&#34;, &#34;end&#34;, str(
            &#34;waves&#34;), text=&#34;Waves&#34;, image=WaveView.getClassIcon())
        # Loading every category separatly is faster than recursivly.
        # This is due to cursor.next function calls in pymongo
        # Adding wave objects
        waves = Wave.fetchObjects({})
        for wave in waves:
            wave_o = WaveController(wave)
            wave_vw = WaveView(self, self.appli.viewframe, self.appli, wave_o)
            wave_vw.addInTreeview(self.waves_node, False)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        scopes = Scope.fetchObjects({})
        for scope in scopes:
            scope_o = ScopeController(scope)
            scope_vw = ScopeView(self, self.appli.viewframe, self.appli, scope_o)
            scope_vw.addInTreeview(None, False)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        intervals = Interval.fetchObjects({})
        for interval in intervals:
            interval_o = IntervalController(interval)
            interval_vw = IntervalView(self, self.appli.viewframe, self.appli, interval_o)
            interval_vw.addInTreeview(None, False)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding ip objects
        self.ips_node = self.insert(&#34;&#34;, &#34;end&#34;, str(
            &#34;ips&#34;), text=&#34;IPs&#34;, image=IpView.getClassIcon())
        ips = Ip.fetchObjects({})
        for ip in ips:
            ip_o = IpController(ip)
            ip_vw = IpView(self, self.appli.viewframe, self.appli, ip_o)
            ip_vw.addInTreeview(None, False)
            self.appli.statusbar.notify(ip_vw.controller.getTags())
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding port objects
        ports = Port.fetchObjects({})
        for port in ports:
            port_o = PortController(port)
            port_vw = PortView(self, self.appli.viewframe, self.appli, port_o)
            port_vw.addInTreeview(None, False)
            self.appli.statusbar.notify(port_vw.controller.getTags())
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding defect objects
        defects = Defect.fetchObjects({&#34;ip&#34;:{&#34;$ne&#34;:&#34;&#34;}})
        for defect in defects:
            defect_o = DefectController(defect)
            defect_vw = DefectView(
                self, self.appli.viewframe, self.appli, defect_o)
            defect_vw.addInTreeview(None)
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        # Adding tool objects
        tools = Tool.fetchObjects({})
        for tool in tools:
            tool_o = ToolController(tool)
            tool_vw = ToolView(self, self.appli.viewframe, self.appli, tool_o)
            tool_vw.addInTreeview(None, False)
            self.appli.statusbar.notify(tool_vw.controller.getTags())
            nbObjectTreated += 1
            if nbObjectTreated % onePercentNbObject == 0:
                step += 1
                dialog.update(step)
        self.sort(self.ips_node)
        self.appli.statusbar.update()
        dialog.destroy()

    def openModifyWindowOf(self, dbId):
        &#34;&#34;&#34;
        Retrieve the View of the database id given and open the modifying form for its model.
        Args:
            dbId: the Mongo Id to open the modification form on.
        &#34;&#34;&#34;
        # self.resetTags()
        objView = self.getViewFromId(str(dbId))
        if objView is not None:
            for widget in self.appli.viewframe.winfo_children():
                widget.destroy()
            objView.form.clear()
            self.openedViewFrameId = str(dbId)
            objView.openModifyWindow()

    def unhide(self, node=None):
        &#34;&#34;&#34;Unhide children of given node.
        Args:
            - node: the node which we want to unhide the children.
                    If this value is None, use the contextualMenu.selection value
                    Default to None.
        &#34;&#34;&#34;
        nodeToUnhideChildren = str(
            self.contextualMenu.selection) if node is None else node
        hidden = sorted(self._hidden, key=lambda x: len(x[0]))
        for hidden in self._hidden:
            itemId = hidden[0]
            parentId = &#39;&#39; if hidden[1] is None else hidden[1]
            if str(parentId) == str(nodeToUnhideChildren):
                view_o = self.getViewFromId(str(itemId))
                if view_o is not None:
                    view_o.controller.delTag(&#34;hidden&#34;)
                try:
                    self.reattach(itemId, parentId, 0)
                except tk.TclError:
                    pass # Le noeud a ete supprime entre temps

    def hideAndUpdate(self):
        &#34;&#34;&#34;Hide object with contextualMenu attached in the treeview and store this effect in its tags.&#34;&#34;&#34;
        self.hide(None, True)

    def hideSelection(self, _event=None):
        &#34;&#34;&#34; Hide selected objects in the treeview and store this effect in their tags.&#34;&#34;&#34;
        selectedNodes = self.selection()
        for node in selectedNodes:
            self.hide(node, True)

    def hide(self, node=None, updateTags=False):
        &#34;&#34;&#34;Hide given node object in the treeview and can store this effect in its tag.
        Args:
            - node: node to hide. If none is given, the contextualMenu.selection value will be used.
                    Default to None.
            - updateTags: mark the object as hidden in its tags. Default to False
        &#34;&#34;&#34;
        nodeToHide = str(
            self.contextualMenu.selection) if node is None else node
        view_o = self.getViewFromId(nodeToHide)
        if view_o is not None:
            if updateTags:
                view_o.controller.addTag(&#34;hidden&#34;)
            self._hidden.append([nodeToHide, view_o.getParent()])
            self.detach(nodeToHide)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>core.Application.Treeviews.PollenisatorTreeview.PollenisatorTreeview</li>
<li>tkinter.ttk.Treeview</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li>tkinter.XView</li>
<li>tkinter.YView</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.closeMenu"><code class="name flex">
<span>def <span class="ident">closeMenu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the contextual menu. Does nothing, just an empty callback</p>
<h2 id="args">Args</h2>
<ul>
<li>_event: not used but mandatory</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeMenu(self, _event=None):
    &#34;&#34;&#34;
    Close the contextual menu. Does nothing, just an empty callback
    Args:
        - _event: not used but mandatory
    &#34;&#34;&#34;
    # Do nothing and close
    return</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.customCommand"><code class="name flex">
<span>def <span class="ident">customCommand</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask the user for a custom tool to launch and which parser it will use.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def customCommand(self, _event=None):
    &#34;&#34;&#34;
    Ask the user for a custom tool to launch and which parser it will use.
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    workers = self.appli.scanManager.monitor.getWorkerList()
    workers.append(&#34;localhost&#34;)
    dialog = ChildDialogCustomCommand(
                self, workers, &#34;localhost&#34;)
    self.wait_window(dialog.app)
    if isinstance(dialog.rvalue, tuple):
        commName = dialog.rvalue[0]
        commArgs = dialog.rvalue[1]
        parser = dialog.rvalue[2]
        worker = dialog.rvalue[3]
    for selected in self.selection():
        view_o = self.getViewFromId(selected)
        if view_o is not None:
            lvl = &#34;network&#34; if isinstance(view_o, ScopeView) else None
            lvl = &#34;wave&#34; if isinstance(view_o, WaveView) else lvl
            lvl = &#34;ip&#34; if isinstance(view_o, IpView) else lvl
            lvl = &#34;port&#34; if isinstance(view_o, PortView) else lvl
            if lvl is not None:
                inst = view_o.controller.getData()
                wave = inst.get(&#34;wave&#34;, &#34;Custom commands&#34;)
                if wave == &#34;Custom commands&#34;:
                    Wave().initialize(&#34;Custom commands&#34;).addInDb()
                tool = Tool()
                tool.initialize(commName, wave, inst.get(&#34;scope&#34;, &#34;&#34;), inst.get(&#34;ip&#34;, None), inst.get(&#34;port&#34;, None), inst.get(
                    &#34;proto&#34;, None), lvl, commArgs, dated=&#34;None&#34;, datef=&#34;None&#34;, scanner_ip=&#34;None&#34;, notes=&#34;Arguments: &#34;+commArgs)
                tool.addInDb()
                if tool is None:
                    print(&#34;Tool already existing.&#34;)
                    return
                self.appli.scanManager.monitor.launchTask(
                    mongoInstance.calendarName, tool, parser, False, worker)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.doPopup"><code class="name flex">
<span>def <span class="ident">doPopup</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a right click is received by the tree view.
Open the contextual menu at the clicked position.</p>
<h2 id="args">Args</h2>
<ul>
<li>event: sent automatically though an event on treeview</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doPopup(self, event):
    &#34;&#34;&#34;Called when a right click is received by the tree view.
    Open the contextual menu at the clicked position.
    Args:
        - event: sent automatically though an event on treeview
    &#34;&#34;&#34;
    if self.contextualMenu is not None:
        self.popupFocusOut()
    self._initContextualsMenus()
    self.contextualMenu.selection = self.identify(
        &#34;item&#34;, event.x, event.y)
    view = self.getViewFromId(str(self.contextualMenu.selection))
    if view is None:
        self.contextualMenu.entryconfig(4, state=tk.DISABLED)
    else:
        self.contextualMenu.entryconfig(4, state=tk.ACTIVE)
    if self.appli.searchMode:
        self.contextualMenu.add_command(
            label=&#34;Show in full tree&#34;, command=self.showInTreeview)
    super().doPopup(event)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.doPopupTag"><code class="name flex">
<span>def <span class="ident">doPopupTag</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a middle click is received by the tree view.
Open the tag menu at the clicked position.</p>
<h2 id="args">Args</h2>
<ul>
<li>event: sent automatically though an event on treeview</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doPopupTag(self, event):
    &#34;&#34;&#34;Called when a middle click is received by the tree view.
    Open the tag menu at the clicked position.
    Args:
        - event: sent automatically though an event on treeview
    &#34;&#34;&#34;
    self.tagsMenu.selection = self.identify(
        &#34;item&#34;, event.x, event.y)
    # display the popup menu
    try:
        self.tagsMenu.post(event.x_root, event.y_root)
    finally:
        # make sure to release the grab (Tk 8.0a1 only)
        self.tagsMenu.grab_release()
    self.tagsMenu.focus_set()
    self.tagsMenu.bind(&#39;&lt;FocusOut&gt;&#39;, self.popupFocusOutTag)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.exportSelection"><code class="name flex">
<span>def <span class="ident">exportSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Popup a window to help a user to export some data from treeview.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportSelection(self, _event=None):
    &#34;&#34;&#34;
    Popup a window to help a user to export some data from treeview.
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    values = set()
    for selected in self.selection():
        view_o = self.getViewFromId(selected)
        if view_o is not None:
            data = view_o.controller.getData()
            for key in data.keys():
                if key == &#34;infos&#34;:
                    for info_keys in data[&#34;infos&#34;]:
                        values.add(&#34;infos.&#34;+info_keys)
                else:
                    values.add(key)
    dialog = ChildDialogExportSelection(self, values)
    self.wait_window(dialog.app)
    if isinstance(dialog.rvalue, list):
        fields_to_export = dialog.rvalue
        f = tk.filedialog.asksaveasfilename(defaultextension=&#34;.csv&#34;)
        if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
            return
        csv_filename = str(f)
        with open(csv_filename, &#39;w&#39;) as f:
            f.write(&#34;, &#34;.join(fields_to_export)+&#34;\n&#34;)
            for selected in self.selection():
                view_o = self.getViewFromId(selected)
                if view_o is not None:
                    line = []
                    modelData = view_o.controller.getData()
                    for field in fields_to_export:
                        if field.startswith(&#34;infos.&#34;):
                            line.append(
                                str(modelData.get(&#34;infos&#34;, {}).get(field[6:], &#34;&#34;)))
                        else:
                            line.append(str(modelData.get(field, &#34;&#34;)))
                    f.write(&#34;, &#34;.join(line)+&#34;\n&#34;)
        dialog = ChildDialogInfo(
            self, &#34;Export completed&#34;, &#34;Your export just finished. You can find it here : &#34;+csv_filename)
    self.wait_window(dialog.app)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.getRows"><code class="name flex">
<span>def <span class="ident">getRows</span></span>(<span>self, startNode='')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all child nodes of the given startNode iid as a list.</p>
<h2 id="args">Args</h2>
<ul>
<li>startNode: node to recursively get children. Default to '' which is rhe treeview root.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>List of all children iid of given node.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRows(self, startNode=&#39;&#39;):
    &#34;&#34;&#34;Returns all child nodes of the given startNode iid as a list.
    Args:
        - startNode: node to recursively get children. Default to &#39;&#39; which is rhe treeview root.
    Returns:
        - List of all children iid of given node.
    &#34;&#34;&#34;
    myRows = []
    children = self.get_children(startNode)
    for child in children:
        myRows.append(child)
        myRows += self.getRows(child)
    return myRows</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>self, node=None, updateTags=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide given node object in the treeview and can store this effect in its tag.</p>
<h2 id="args">Args</h2>
<ul>
<li>node: node to hide. If none is given, the contextualMenu.selection value will be used.
Default to None.</li>
<li>updateTags: mark the object as hidden in its tags. Default to False</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide(self, node=None, updateTags=False):
    &#34;&#34;&#34;Hide given node object in the treeview and can store this effect in its tag.
    Args:
        - node: node to hide. If none is given, the contextualMenu.selection value will be used.
                Default to None.
        - updateTags: mark the object as hidden in its tags. Default to False
    &#34;&#34;&#34;
    nodeToHide = str(
        self.contextualMenu.selection) if node is None else node
    view_o = self.getViewFromId(nodeToHide)
    if view_o is not None:
        if updateTags:
            view_o.controller.addTag(&#34;hidden&#34;)
        self._hidden.append([nodeToHide, view_o.getParent()])
        self.detach(nodeToHide)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hideAndUpdate"><code class="name flex">
<span>def <span class="ident">hideAndUpdate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide object with contextualMenu attached in the treeview and store this effect in its tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hideAndUpdate(self):
    &#34;&#34;&#34;Hide object with contextualMenu attached in the treeview and store this effect in its tags.&#34;&#34;&#34;
    self.hide(None, True)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hideSelection"><code class="name flex">
<span>def <span class="ident">hideSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide selected objects in the treeview and store this effect in their tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hideSelection(self, _event=None):
    &#34;&#34;&#34; Hide selected objects in the treeview and store this effect in their tags.&#34;&#34;&#34;
    selectedNodes = self.selection()
    for node in selectedNodes:
        self.hide(node, True)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the user interface widgets and binds them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    &#34;&#34;&#34;Initialize the user interface widgets and binds them.&#34;&#34;&#34;
    self._initContextualsMenus()
    self.heading(&#39;#0&#39;, text=&#39;Object&#39;, anchor=tk.W)
    self.column(&#39;#0&#39;, stretch=tk.YES, minwidth=300, width=300)
    self.bind(&#34;&lt;Button-3&gt;&#34;, self.doPopup)
    self.bind(&#34;&lt;Button-2&gt;&#34;, self.doPopupTag)
    #self.bind(&#34;&lt;Return&gt;&#34;, self.onTreeviewSelect)
    #self.bind(&#34;&lt;Button-1&gt;&#34;, self.onTreeviewSelect)
    self.bind(&#34;&lt;&lt;TreeviewSelect&gt;&gt;&#34;, self.onTreeviewSelect)
    self.bind(&#39;&lt;Delete&gt;&#39;, self.deleteSelected)
    self.bind(&#39;h&#39;, self.hideSelection)
    self.bind(&#34;&lt;Shift-Down&gt;&#34;, self.openNextSameTypeNode)
    self.bind(&#34;&lt;Shift-Up&gt;&#34;, self.openPrevSameTypeNode)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, searchModel=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the treeview with database information</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>searchModel</code></strong></dt>
<dd>(DEPRECATED) a search object default to None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, searchModel=None):
    &#34;&#34;&#34;
    Load the treeview with database information
    Args:
        searchModel: (DEPRECATED) a search object default to None
    &#34;&#34;&#34;
    for widget in self.appli.viewframe.winfo_children():
        widget.destroy()
    # Reattach hidden as get_children won&#39;t get them otherwise
    hidden = sorted(self._hidden, key=lambda x: len(x[0]))
    for hide in hidden:
        try:
            self.reattach(hide[0], hide[1], 0)
        except tk.TclError:
            pass
    # Clear the tree
    mongoInstance = MongoCalendar.getInstance()
    self.heading(&#34;#0&#34;, text=mongoInstance.calendarName)
    self.delete(*self.get_children())
    self._hidden = []
    if searchModel is None:
        self._load()
    elif searchModel.query == &#34;&#34;:
        self._load()
    else:
        viewsFound = searchModel.getViews(
            self, self.appli.viewframe, self.appli)
        for viewFound in viewsFound:
            viewFound.addInTreeview(&#39;&#39;, False)
    self.loadState(mongoInstance.calendarName)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.notify"><code class="name flex">
<span>def <span class="ident">notify</span></span>(<span>self, db, collection, iid, action, _parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for the observer implemented in mongo.py.
Each time an object is inserted, updated or deleted the standard way, this function will be called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>collection</code></strong></dt>
<dd>the collection that has been modified</dd>
<dt><strong><code>iid</code></strong></dt>
<dd>the mongo ObjectId _id that was modified/inserted/deleted</dd>
<dt><strong><code>action</code></strong></dt>
<dd>string "update" or "insert" or "delete". It was the action performed on the iid</dd>
<dt><strong><code>_parent</code></strong></dt>
<dd>Not used. the mongo ObjectId of the parent. Only if action in an insert. Not used anymore</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify(self, db, collection, iid, action, _parent):
    &#34;&#34;&#34;
    Callback for the observer implemented in mongo.py.
    Each time an object is inserted, updated or deleted the standard way, this function will be called.

    Args:
        collection: the collection that has been modified
        iid: the mongo ObjectId _id that was modified/inserted/deleted
        action: string &#34;update&#34; or &#34;insert&#34; or &#34;delete&#34;. It was the action performed on the iid
        _parent: Not used. the mongo ObjectId of the parent. Only if action in an insert. Not used anymore
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    if not mongoInstance.hasACalendarOpen():
        return
    if mongoInstance.calendarName != db:
        return
    # Delete
    if action == &#34;delete&#34;:
        if collection == &#34;defects&#34;:
            view = self.getViewFromId(str(iid))
            if view is not None:
                view.beforeDelete()
                self.appli.statusbar.notify([],view.controller.getTags())
        try:
            self.delete(ObjectId(iid))
        except tk.TclError:
            pass  # item was not inserted in the treeview

    # Insert
    if action == &#34;insert&#34;:
        view = None
        res = mongoInstance.find(collection, {&#34;_id&#34;: ObjectId(iid)}, False)
        if collection == &#34;tools&#34;:
            view = ToolView(self, self.appli.viewframe,
                            self.appli, ToolController(Tool(res)))
        elif collection == &#34;waves&#34;:
            view = WaveView(self, self.appli.viewframe,
                            self.appli, WaveController(Wave(res)))
        elif collection == &#34;scopes&#34;:
            view = ScopeView(self, self.appli.viewframe,
                             self.appli, ScopeController(Scope(res)))
        elif collection == &#34;ports&#34;:
            view = PortView(self, self.appli.viewframe,
                            self.appli, PortController(Port(res)))
        elif collection == &#34;ips&#34;:
            view = IpView(self, self.appli.viewframe,
                          self.appli, IpController(Ip(res)))
        elif collection == &#34;intervals&#34;:
            view = IntervalView(self, self.appli.viewframe,
                                self.appli, IntervalController(Interval(res)))
        elif collection == &#34;defects&#34;:
            view = DefectView(self, self.appli.viewframe,
                            self.appli, DefectController(Defect(res)))
        try:
            if view is not None:
                view.addInTreeview()
                view.insertReceived()
                self.appli.statusbar.notify(view.controller.getTags())
        except tk.TclError:
            pass

    if action == &#34;update&#34;:
        try:
            view = self.getViewFromId(str(iid))
            if view is not None:
                oldTags = self.item(str(iid))[&#34;tags&#34;]
                view.controller.actualize()
                self.appli.statusbar.notify(view.controller.getTags(), oldTags)
                self.item(str(iid), text=str(
                    view.controller.getModelRepr()), image=view.getIcon())
        except tk.TclError:
            if view is not None:
                view.addInTreeview()
        if str(self.appli.openedViewFrameId) == str(iid):
            for widget in self.appli.viewframe.winfo_children():
                widget.destroy()
            view.openModifyWindow()
        if view is not None:
            view.updateReceived()
    self.appli.statusbar.update()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.onTreeviewSelect"><code class="name flex">
<span>def <span class="ident">onTreeviewSelect</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a line is selected on the treeview
Open the selected object view on the view frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onTreeviewSelect(self, event=None):
    &#34;&#34;&#34;Called when a line is selected on the treeview
    Open the selected object view on the view frame.
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    selection = self.selection()
    if len(selection) == 1:
        item = super().onTreeviewSelect(event)
        if isinstance(item, str):
            mongoInstance = MongoCalendar.getInstance()
            self.saveState(mongoInstance.calendarName)
            if str(item) == &#34;waves&#34;:
                objView = WaveView(self, self.appli.viewframe,
                                self.appli, WaveController(Wave()))
                objView.openInsertWindow()
            elif str(item) == &#34;ips&#34;:
                objView = MultipleIpView(
                    self, self.appli.viewframe, self.appli, IpController(Ip()))
                objView.openInsertWindow()
            elif &#34;intervals&#34; in str(item):
                wave = Wave.fetchObject(
                    {&#34;_id&#34;: ObjectId(IntervalView.treeviewListIdToDb(item))})
                objView = IntervalView(self, self.appli.viewframe, self.appli, IntervalController(
                    Interval().initialize(wave.wave)))
                objView.openInsertWindow()
            elif &#34;scopes&#34; in str(item):
                wave = Wave.fetchObject(
                    {&#34;_id&#34;: ObjectId(ScopeView.treeviewListIdToDb(item))})
                objView = MultipleScopeView(
                    self, self.appli.viewframe, self.appli, ScopeController(Scope().initialize(wave.wave)))
                objView.openInsertWindow()
        else:
            self.openModifyWindowOf(item)
    elif len(selection) &gt; 1:
        # Multi select:
        multiView = MultiSelectionView(self, self.appli.viewframe, self.appli)
        for widget in self.appli.viewframe.winfo_children():
            widget.destroy()
        multiView.form.clear()
        multiView.openModifyWindow()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openModifyWindowOf"><code class="name flex">
<span>def <span class="ident">openModifyWindowOf</span></span>(<span>self, dbId)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the View of the database id given and open the modifying form for its model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dbId</code></strong></dt>
<dd>the Mongo Id to open the modification form on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openModifyWindowOf(self, dbId):
    &#34;&#34;&#34;
    Retrieve the View of the database id given and open the modifying form for its model.
    Args:
        dbId: the Mongo Id to open the modification form on.
    &#34;&#34;&#34;
    # self.resetTags()
    objView = self.getViewFromId(str(dbId))
    if objView is not None:
        for widget in self.appli.viewframe.winfo_children():
            widget.destroy()
        objView.form.clear()
        self.openedViewFrameId = str(dbId)
        objView.openModifyWindow()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openNextSameTypeNode"><code class="name flex">
<span>def <span class="ident">openNextSameTypeNode</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Open the first node of the same type below the currently selected object on the tree view.</p>
<h2 id="args">Args</h2>
<ul>
<li>_event: not used but mandatory</li>
</ul>
<h2 id="return">Return</h2>
<p>return the string "break" to stop processing the event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openNextSameTypeNode(self, _event):
    &#34;&#34;&#34;Open the first node of the same type below the currently selected object on the tree view.
    Args:
        - _event: not used but mandatory
    Return:
        return the string &#34;break&#34; to stop processing the event
    &#34;&#34;&#34;
    fromNode = self.selection()
    if fromNode:
        fromNode = fromNode[0]
        rows = self.getRows()
        pos = rows.index(fromNode)
        if pos+1 &lt; len(rows):
            view_o = self.getViewFromId(fromNode)
            classToFind = view_o.__class__
            for row in rows[pos+1:]:
                cmp_view_o = self.getViewFromId(row)
                if classToFind == cmp_view_o.__class__:
                    self.see(row)
                    self.focus(row)
                    self.selection_set(row)
                    return &#34;break&#34;
    return &#34;break&#34;</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openPrevSameTypeNode"><code class="name flex">
<span>def <span class="ident">openPrevSameTypeNode</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Open the first node of the same type above the currently selected object on the tree view.</p>
<h2 id="args">Args</h2>
<ul>
<li>_event: not used but mandatory</li>
</ul>
<h2 id="return">Return</h2>
<p>return the string "break" to stop processing the event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openPrevSameTypeNode(self, _event):
    &#34;&#34;&#34;Open the first node of the same type above the currently selected object on the tree view.
    Args:
        - _event: not used but mandatory
    Return:
        return the string &#34;break&#34; to stop processing the event
    &#34;&#34;&#34;
    fromNode = self.selection()
    if fromNode:
        fromNode = fromNode[0]
        rows = self.getRows()
        pos = rows.index(fromNode)
        if pos-1 &gt; 0:
            view_o = self.getViewFromId(fromNode)
            classToFind = view_o.__class__
            for row_nth in range(pos-1, -1, -1):
                row = rows[row_nth]
                cmp_view_o = self.getViewFromId(row)
                if classToFind == cmp_view_o.__class__:
                    self.see(row)
                    self.focus(row)
                    self.selection_set(row)
                    return &#34;break&#34;
    return &#34;break&#34;</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.popupFocusOutTag"><code class="name flex">
<span>def <span class="ident">popupFocusOutTag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the tag contextual menu is unfocused.
Close the tag contextual menu.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popupFocusOutTag(self, _=None):
    &#34;&#34;&#34;Called when the tag contextual menu is unfocused.
    Close the tag contextual menu.
    &#34;&#34;&#34;
    self.tagsMenu.unpost()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias to load function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Alias to load function&#34;&#34;&#34;
    self.load()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.setTagFromMenubar"><code class="name flex">
<span>def <span class="ident">setTagFromMenubar</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the tags of every selected object in the treeview to the one selected in the tag contextual menu.</p>
<h2 id="args">Args</h2>
<ul>
<li>name: the tag name clicked</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTagFromMenubar(self, name):
    &#34;&#34;&#34;
    Change the tags of every selected object in the treeview to the one selected in the tag contextual menu.
    Args:
        - name: the tag name clicked
    &#34;&#34;&#34;
    for selected in self.selection():
        view_o = self.getViewFromId(selected)
        view_o.controller.setTags([name])</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.showInTreeview"><code class="name flex">
<span>def <span class="ident">showInTreeview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unfilter the treeview and focus the node stored in the contextualMenu.selection variable0
Also select it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showInTreeview(self, _=None):
    &#34;&#34;&#34;Unfilter the treeview and focus the node stored in the contextualMenu.selection variable0
    Also select it.
    &#34;&#34;&#34;
    node = str(self.contextualMenu.selection)
    self.unfilter()
    self.see(node)
    self.focus(node)
    self.selection_set(node)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.tagClicked"><code class="name flex">
<span>def <span class="ident">tagClicked</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for an event. If the function was called directly it would not work.</p>
<h2 id="args">Args</h2>
<ul>
<li>name: the tag name clicked</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tagClicked(self, name):
    &#34;&#34;&#34;Callback for an event. If the function was called directly it would not work.
    Args:
        - name: the tag name clicked
    &#34;&#34;&#34;
    return lambda : self.setTagFromMenubar(name)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.unhide"><code class="name flex">
<span>def <span class="ident">unhide</span></span>(<span>self, node=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unhide children of given node.</p>
<h2 id="args">Args</h2>
<ul>
<li>node: the node which we want to unhide the children.
If this value is None, use the contextualMenu.selection value
Default to None.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unhide(self, node=None):
    &#34;&#34;&#34;Unhide children of given node.
    Args:
        - node: the node which we want to unhide the children.
                If this value is None, use the contextualMenu.selection value
                Default to None.
    &#34;&#34;&#34;
    nodeToUnhideChildren = str(
        self.contextualMenu.selection) if node is None else node
    hidden = sorted(self._hidden, key=lambda x: len(x[0]))
    for hidden in self._hidden:
        itemId = hidden[0]
        parentId = &#39;&#39; if hidden[1] is None else hidden[1]
        if str(parentId) == str(nodeToUnhideChildren):
            view_o = self.getViewFromId(str(itemId))
            if view_o is not None:
                view_o.controller.delTag(&#34;hidden&#34;)
            try:
                self.reattach(itemId, parentId, 0)
            except tk.TclError:
                pass # Le noeud a ete supprime entre temps</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Pollenisator.core.Application.Treeviews" href="index.html">Pollenisator.core.Application.Treeviews</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview">CalendarTreeview</a></code></h4>
<ul class="">
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.closeMenu" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.closeMenu">closeMenu</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.customCommand" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.customCommand">customCommand</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.doPopup" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.doPopup">doPopup</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.doPopupTag" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.doPopupTag">doPopupTag</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.exportSelection" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.exportSelection">exportSelection</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.getRows" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.getRows">getRows</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hide" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hide">hide</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hideAndUpdate" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hideAndUpdate">hideAndUpdate</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hideSelection" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.hideSelection">hideSelection</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.initUI" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.initUI">initUI</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.load" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.load">load</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.notify" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.notify">notify</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.onTreeviewSelect" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.onTreeviewSelect">onTreeviewSelect</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openModifyWindowOf" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openModifyWindowOf">openModifyWindowOf</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openNextSameTypeNode" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openNextSameTypeNode">openNextSameTypeNode</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openPrevSameTypeNode" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.openPrevSameTypeNode">openPrevSameTypeNode</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.popupFocusOutTag" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.popupFocusOutTag">popupFocusOutTag</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.refresh" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.refresh">refresh</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.setTagFromMenubar" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.setTagFromMenubar">setTagFromMenubar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.showInTreeview" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.showInTreeview">showInTreeview</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.tagClicked" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.tagClicked">tagClicked</a></code></li>
<li><code><a title="Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.unhide" href="#Pollenisator.core.Application.Treeviews.CalendarTreeview.CalendarTreeview.unhide">unhide</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>