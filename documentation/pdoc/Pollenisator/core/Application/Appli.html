<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>Pollenisator.core.Application.Appli API documentation</title>
<meta name="description" content="Pollenisator client GUI window." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Pollenisator.core.Application.Appli</code></h1>
</header>
<section id="section-intro">
<p>Pollenisator client GUI window.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Pollenisator client GUI window.
&#34;&#34;&#34;
import traceback
import threading
import tkinter.filedialog
import tkinter as tk
import tkinter.messagebox
import tkinter.simpledialog
import tkinter.ttk as ttk
import sys
from tkinter import TclError
import os
import re
from PIL import ImageTk, Image
from shutil import which
import core.Components.Utils as Utils
from core.Application.Treeviews.CalendarTreeview import CalendarTreeview
from core.Application.Treeviews.CommandsTreeview import CommandsTreeview
from core.Application.Dialogs.ChildDialogCombo import ChildDialogCombo
from core.Application.Dialogs.ChildDialogQuestion import ChildDialogQuestion
from core.Application.Dialogs.ChildDialogConnect import ChildDialogConnect
from core.Application.Dialogs.ChildDialogNewCalendar import ChildDialogNewCalendar
from core.Application.Dialogs.ChildDialogException import ChildDialogException
from core.Application.Dialogs.ChildDialogInfo import ChildDialogInfo
from core.Application.StatusBar import StatusBar
from core.Components.mongo import MongoCalendar
from core.Components.ScanManager import ScanManager
from core.Components.Summary import Summary
from core.Components.DashBoard import DashBoard
from core.Components.Settings import Settings
from core.Components.Report import Report
from core.Components.Filter import Filter
from core.Controllers.ScopeController import ScopeController
from core.Models.Command import Command
from core.Models.Scope import Scope
from core.Models.Wave import Wave
from core.Models.Interval import Interval
from core.Components.FileStorage import FileStorage

class FloatingHelpWindow(tk.Toplevel):
    &#34;&#34;&#34;floating basic window with helping text inside
    Inherit tkinter TopLevel
    Found on the internet (stackoverflow) but did not keep link sorry...
    &#34;&#34;&#34;

    def __init__(self, w, h, posx, posy, *args, **kwargs):
        tk.Toplevel.__init__(self, *args, **kwargs)
        self.title(&#39;Help: search&#39;)
        self.x = posx
        self.y = posy
        self.geometry(str(w)+&#34;x&#34;+str(h)+&#34;+&#34;+str(posx)+&#34;+&#34;+str(posy))
        self.resizable(0, 0)
        self.config(bg=&#39;light yellow&#39;)
        self.grip = tk.Label(self, bitmap=&#34;gray25&#34;)
        self.grip.pack(side=&#34;left&#34;, fill=&#34;y&#34;)
        label = tk.Label(self, bg=&#39;light yellow&#39;, fg=&#39;black&#39;,
                         justify=tk.LEFT, text=Filter.help())
        label.pack()
        self.overrideredirect(True)
        self.grip.bind(&#34;&lt;ButtonPress-1&gt;&#34;, self.startMove)
        self.grip.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.stopMove)
        self.grip.bind(&#34;&lt;B1-Motion&gt;&#34;, self.onMotion)

    def startMove(self, event):
        &#34;&#34;&#34; Floating window dragging started
            Args:
                event: event.x and event.y hold the new position of the window
        &#34;&#34;&#34;
        self.x = event.x
        self.y = event.y

    def stopMove(self, _event):
        &#34;&#34;&#34; Floating window dragging stopped
            Args:
                _event: Not used but mandatory
        &#34;&#34;&#34;
        self.x = None
        self.y = None

    def onMotion(self, event):
        &#34;&#34;&#34; Floating window dragging ongoing
            Args:
                event: event.x and event.y hold the new position of the window
        &#34;&#34;&#34;
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.winfo_x() + deltax
        y = self.winfo_y() + deltay
        self.geometry(&#34;+%s+%s&#34; % (x, y))


class AutocompleteEntry(ttk.Entry):
    &#34;&#34;&#34;Inherit ttk.Entry.
    An entry with an autocompletion ability.
    Found on the internet : http://code.activestate.com/recipes/578253-an-entry-with-autocompletion-for-the-tkinter-gui/
    But a bit modified.
    &#34;&#34;&#34;

    def __init__(self, settings, *args, **kwargs):
        &#34;&#34;&#34;Constructor
        Args:
            settings: a dict of Settings:
                * histo_filters: number of history search to display
            args: not used
            kwargs: 
                * width: default to 100
        &#34;&#34;&#34;
        ttk.Entry.__init__(self, *args, **kwargs)
        self.width = kwargs.get(&#34;width&#34;,100)
        self.lista = set()
        self.var = self[&#34;textvariable&#34;]
        if self.var == &#39;&#39;:
            self.var = self[&#34;textvariable&#34;] = tk.StringVar()
        self.var.trace(&#39;w&#39;, self.changed)
        
        self.bind(&#34;&lt;Right&gt;&#34;, self.selection)
        self.bind(&#34;&lt;Up&gt;&#34;, self.upArrow)
        self.bind(&#34;&lt;Down&gt;&#34;, self.downArrow)
        self.settings = settings
        self.lb = None
        self.lb_up = False

    def changed(self, _name=None, _index=None, _mode=None):
        &#34;&#34;&#34;
        Called when the entry is modified. Perform autocompletion.
        Args:
            _name: not used but mandatory for tk.StringVar.trace
            _index: not used but mandatory for tk.StringVar.trace
            _mode: not used but mandatory for tk.StringVar.trace
        &#34;&#34;&#34;
        words = self.comparison()
        if words:
            if not self.lb_up:
                self.lb = tk.Listbox(width=self.width)
                self.lb.bind(&#34;&lt;Double-Button-1&gt;&#34;, self.selection)
                self.lb.bind(&#34;&lt;Right&gt;&#34;, self.selection)
                self.lb.bind(&#34;&lt;Leave&gt;&#34;, self.quit)
                self.bind(&#34;&lt;Escape&gt;&#34;, self.quit)
                self.lb.place(x=self.winfo_x()+133,
                                y=self.winfo_y()+self.winfo_height()+20)
                self.lb_up = True
            self.lb.delete(0, tk.END)
            for w in words:
                self.lb.insert(tk.END, w)
        else:
            self.quit()

    def quit(self, _event=None):
        &#34;&#34;&#34;
        Callback function to destroy the label shown
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            self.lb.destroy()
            self.lb_up = False
    
    def reset(self):
        &#34;&#34;&#34;
        quit and reset filter bar
        &#34;&#34;&#34;
        self.quit()
        self.var.set(&#34;&#34;)

    def selection(self, _event):
        &#34;&#34;&#34;
        Called when an autocompletion option is chosen. 
        Change entry content and close autocomplete.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            self.var.set(self.lb.get(tk.ACTIVE))
            self.lb.destroy()
            self.lb_up = False
            self.icursor(tk.END)
            #self.changed()

    def upArrow(self, _event):
        &#34;&#34;&#34;
        Called when the up arrow is pressed. Navigate in autocompletion options
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            if self.lb.curselection() == ():
                index = &#39;0&#39;
            else:
                index = self.lb.curselection()[0]
            if index != &#39;0&#39;:
                self.lb.selection_clear(first=index)
                index = str(int(index)-1)
                self.lb.selection_set(first=index)
                self.lb.activate(index)

    def downArrow(self, _event):
        &#34;&#34;&#34;
        Called when the down arrow is pressed. Navigate in autocompletion options
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            if self.lb.curselection() == ():
                index = &#39;0&#39;
            else:
                index = self.lb.curselection()[0]
            if index != tk.END:
                self.lb.selection_clear(first=index)
                index = str(int(index)+1)
                self.lb.selection_set(first=index)
                self.lb.activate(index)

    def comparison(self):
        &#34;&#34;&#34;
        Search suggestions in regard of what is in the entry
        &#34;&#34;&#34;
        values = set(self.settings.local_settings.get(&#34;histo_filters&#34;, []))
        self.lista = values
        content = self.var.get().strip()
        if content == &#34;&#34;:
            return []
        pattern = re.compile(&#39;.*&#39; + re.escape(content) + &#39;.*&#39;)
        return [w for w in self.lista if re.match(pattern, w)]


class Appli(ttk.Frame):
    &#34;&#34;&#34;
    Main tkinter graphical application object.
    &#34;&#34;&#34;

    def __init__(self, parent):
        &#34;&#34;&#34;
        Initialise the application

        Args:
            parent: The main tk window.
        &#34;&#34;&#34;
        # Lexic:
        # view frame : the frame in the tab that will hold forms.
        # Tree view : the tree on the left of the window.
        # frame tree view : a frame around the tree view (useful to attach a scrollbar to a treeview)
        # canvas : a canvas object (useful to attach a scrollbar to a frame)
        # paned : a Paned widget is used to separate two other widgets and display a one over the other if desired
        #           Used to separate the treeview frame and view frame.
        
        self.parent = parent  #  parent tkinter window
        #  already read notifications from previous notification reading iteration
        self.old_notifs = []
        self.notifications_timers = None
        tk.Tk.report_callback_exception = self.show_error
        self.setStyle()
        # HISTORY : Main view and command where historically in the same view;
        # This results in lots of widget here with a confusing naming style
        ttk.Frame.__init__(self, parent)
        #### core components (Tab menu on the left objects)####
        self.settings = Settings()
        self.settingViewFrame = None
        self.dashboard = DashBoard()
        self.dashboardViewFrame = None
        self.report = Report(self.settings)
        self.reportViewFrame = None
        self.summary = Summary(self.parent)
        self.summaryViewFrame = None
        self.scanManager = None  #  Loaded when clicking on it if linux only
        self.scanViewFrame = None
        # Icons for each tab menu
        self.dashboard_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_dashboard.png&#34;))
        self.main_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_main.png&#34;))
        self.commands_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_commands.png&#34;))
        self.scan_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_scan.png&#34;))
        self.settings_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_settings.png&#34;))
        self.summary_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_summary.png&#34;))
        self.report_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_report.png&#34;))
        self.terminal_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_terminal.png&#34;))
        
        #### MAIN VIEW ####
        self.openedViewFrameId = None
        self.mainPageFrame = None
        self.paned = None
        self.canvasMain = None
        self.viewframe = None
        self.frameTw = None
        self.treevw = None
        self.myscrollbarMain = None
        #### COMMAND VIEW ####
        self.commandsPageFrame = None
        self.commandPaned = None
        self.commandsFrameTw = None
        self.canvas = None
        self.commandsViewFrame = None
        self.myscrollbarCommand = None
        self.commandsTreevw = None
        #### SEARCH BAR ####
        # boolean set to true when the main tree view is displaying search results
        self.searchMode = False
        self.searchBar = None  # the search bar component
        self.btnHelp = None  # help button on the right of the search bar
        self.photo = None  # the ? image
        self.helpFrame = None  # the floating help frame poping when the button is pressed

        # Connect to database and choose database to open
        abandon = False
        mongoInstance = MongoCalendar.getInstance()
        while not mongoInstance.isUserConnected() and not abandon:
            abandon = self.promptForConnection() is None
        if not abandon:
            mongoInstance.attach(self)
            self.initUI()
            # Will trigger promptForCalendarOpen when tab will be opened
        else:
            self.onClosing()
            parent.destroy()

    def show_error(self, *args):
        &#34;&#34;&#34;Callback for tk.Tk.report_callback_exception.
        Open a window to display exception with some actions possible

        Args:
            args: 3 args are required for tk.Tk.report_callback_exception event to be given to traceback.format_exception(args[0], args[1], args[2])
        
        Raises:
            If an exception occurs in this handler thread, will print it and exit with exit code 1
        &#34;&#34;&#34;
        try:
            err = traceback.format_exception(args[0], args[1], args[2])
            dialog = ChildDialogException(self, &#39;Exception occured&#39;, err)
            self.wait_window(dialog.app)
        except Exception as e:
            print(e)
            sys.exit(1)

    def promptForConnection(self):
        &#34;&#34;&#34;Close current database connection and open connection form for the user
        
        Returns: 
            The number of pollenisator database found, 0 if the connection failed.&#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.reinitConnection()
        connectDialog = ChildDialogConnect(self.parent)
        self.wait_window(connectDialog.app)
        return connectDialog.rvalue

    def getCentralizedFiles(self):
        &#34;&#34;&#34;Download from SFTP server all files of current database in local directory
        &#34;&#34;&#34;
        fs = FileStorage()
        fs.open()
        fs.getResults()
        fs.close()
        tkinter.messagebox.showinfo(
            &#34;Centralization completed&#34;, &#34;Files were download in results/&#34;)

    def submitIssue(self):
        &#34;&#34;&#34;Open git issues in browser&#34;&#34;&#34;
        import webbrowser
        webbrowser.open_new_tab(&#34;https://github.com/AlgoSecure/Pollenisator/issues&#34;)

    def removeFiles(self, calendarName):
        &#34;&#34;&#34;Open git issues in browser
        Args:
            calendarName: database name to be removed.
        &#34;&#34;&#34;
        fs = FileStorage()
        fs.open()
        fs.rmDbResults(calendarName.strip())
        fs.rmDbProofs(calendarName.strip())
        fs.close()
        tkinter.messagebox.showinfo(
            &#34;Deleting tool&#34;, &#34;Files were removed on sftp for &#34;+str(calendarName))

    def readNotifications(self):
        &#34;&#34;&#34;
        Read notifications from database every 0.5 or so second. Notifications are used to exchange informations between applications.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        for old_notif in self.old_notifs:
            mongoInstance.deleteFromDb(&#34;pollenisator&#34;, &#34;notifications&#34;, {&#34;_id&#34;: old_notif})
        self.old_notifs = []
        try:
            notifications = mongoInstance.findInDb(&#34;pollenisator&#34;, &#34;notifications&#34;, {&#34;$or&#34;:[{&#34;db&#34;:str(mongoInstance.calendarName)}, {&#34;db&#34;:&#34;pollenisator&#34;}]})
            for notification in notifications:
                # print(&#34;Notification received &#34;+str(notification[&#34;db&#34;])+&#34;/&#34;+str(notification[&#34;collection&#34;])+&#34; iid=&#34;+str(notification[&#34;iid&#34;])+&#34; action=&#34;+str(notification[&#34;action&#34;]))
                self.old_notifs.append(notification[&#34;_id&#34;])
                if notification[&#34;db&#34;] == &#34;pollenisator&#34;:
                    if notification[&#34;collection&#34;] == &#34;workers&#34;:
                        self.scanManager.notify(notification[&#34;iid&#34;], notification[&#34;action&#34;])
                    elif &#34;commands&#34; in notification[&#34;collection&#34;]:
                        self.commandsTreevw.notify(notification[&#34;db&#34;], notification[&#34;collection&#34;], notification[&#34;iid&#34;], notification[&#34;action&#34;], notification.get(&#34;parent&#34;, &#34;&#34;))
                else:
                    self.treevw.notify(notification[&#34;db&#34;], notification[&#34;collection&#34;],
                                    notification[&#34;iid&#34;], notification[&#34;action&#34;], notification.get(&#34;parent&#34;, &#34;&#34;))
        except Exception as e:
            print(str(e))
        self.notifications_timers = threading.Timer(
            0.5, self.readNotifications)
        self.notifications_timers.start()

    def onClosing(self):
        &#34;&#34;&#34;
        Close the application properly.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.dettach(self)
        if self.scanManager is not None:
            self.scanManager.stop()
        print(&#34;Stopping notifications...&#34;)
        if self.notifications_timers is not None:
            self.notifications_timers.cancel()
        if self.scanManager is not None:
            self.scanManager.monitor.stopWorkersTimer()
        print(&#34;Stopping application...&#34;)
        self.quit()

    def _initMenuBar(self):
        &#34;&#34;&#34;
        Create the bar menu on top of the screen.
        &#34;&#34;&#34;
        menubar = tk.Menu(self.parent, tearoff=0, bd=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        self.parent.config(menu=menubar)

        self.parent.bind(&#39;&lt;F5&gt;&#39;, self.refreshView)
        self.parent.bind(&#39;&lt;Control-o&gt;&#39;, self.promptCalendarName)
        fileMenu = tk.Menu(menubar, tearoff=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        fileMenu.add_command(label=&#34;New&#34;, command=self.selectNewCalendar)
        fileMenu.add_command(label=&#34;Open (Ctrl+o)&#34;,
                             command=self.promptCalendarName)
        fileMenu.add_command(label=&#34;Connect to server&#34;, command=self.promptForConnection)
        fileMenu.add_command(label=&#34;Copy&#34;, command=self.wrapCopyDb)
        fileMenu.add_command(label=&#34;Delete a database&#34;,
                             command=self.deleteACalendar)
        fileMenu.add_command(label=&#34;Export database&#34;,
                             command=self.exportCalendar)
        fileMenu.add_command(label=&#34;Import database&#34;,
                             command=self.importCalendar)
        fileMenu.add_command(label=&#34;Export commands&#34;,
                             command=self.exportCommands)
        fileMenu.add_command(label=&#34;Import commands&#34;,
                             command=self.importCommands)

        fileMenu.add_command(label=&#34;Exit&#34;, command=self.onExit)
        fileMenu2 = tk.Menu(menubar, tearoff=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        fileMenu2.add_command(label=&#34;Reset unfinished tools&#34;,
                              command=self.resetUnfinishedTools)
        fileMenu2.add_command(label=&#34;Refresh (F5)&#34;,
                              command=self.refreshView)
        fileMenu2.add_command(label=&#34;Get centralized files&#34;,
                              command=self.getCentralizedFiles)
        fileMenu3 = tk.Menu(menubar, tearoff=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        fileMenu3.add_command(label=&#34;Submit a bug or feature&#34;,
                              command=self.submitIssue)
        menubar.add_cascade(label=&#34;File&#34;, menu=fileMenu)
        menubar.add_cascade(label=&#34;Scans&#34;, menu=fileMenu2)
        menubar.add_cascade(label=&#34;Help&#34;, menu=fileMenu3)

    def setStyle(self, _event=None):
        &#34;&#34;&#34;
        Set the pollenisator window widget style using ttk.Style
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        style = ttk.Style(self.parent)
        style.theme_use(&#34;clam&#34;)
        try:
            style.element_create(&#39;Plain.Notebook.tab&#39;, &#34;from&#34;, &#39;default&#39;)
        except TclError:
            pass # ALready exists
        style.configure(&#34;Treeview.Heading&#34;, background=&#34;#73B723&#34;,
                        foreground=&#34;white&#34;, relief=&#34;flat&#34;)
        style.map(&#39;Treeview.Heading&#39;, background=[(&#39;active&#39;, &#39;#73B723&#39;)])
        style.configure(&#34;TLabelframe&#34;, background=&#34;white&#34;,
                        labeloutside=False, bordercolor=&#34;#73B723&#34;)
        style.configure(&#39;TLabelframe.Label&#39;, background=&#34;#73B723&#34;,
                        foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))
        style.configure(&#34;TProgressbar&#34;,
                        background=&#34;#73D723&#34;, foreground=&#34;#73D723&#34;, troughcolor=&#34;white&#34;, darkcolor=&#34;#73D723&#34;, lightcolor=&#34;#73D723&#34;)
        style.configure(&#34;Important.TFrame&#34;, background=&#34;#73B723&#34;)
        style.configure(&#34;TFrame&#34;, background=&#34;white&#34;)
        style.configure(&#34;Important.TLabel&#34;, background=&#34;#73B723&#34;, foreground=&#34;white&#34;)
        style.configure(&#34;TLabel&#34;, background=&#34;white&#34;)
        style.configure(&#34;TCombobox&#34;, background=&#34;white&#34;)
        style.configure(&#34;TCheckbutton&#34;, background=&#34;white&#34;,
                        font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))
        style.configure(&#34;TButton&#34;, background=&#34;#73B723&#34;,
                        foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), borderwidth=1)
        style.configure(&#34;TNotebook&#34;, background=&#34;#73B723&#34;, foreground=&#34;white&#34;, font=(
            &#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), tabposition=&#39;wn&#39;, borderwidth=0, width=100)

        style.configure(&#34;TNotebook.Tab&#34;, background=&#34;#73B723&#34;, borderwidth=0,
                        foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), padding=20, bordercolor=&#34;#73B723&#34;)
        style.map(&#39;TNotebook.Tab&#39;, background=[(&#39;active&#39;, &#39;#73C723&#39;), (&#34;selected&#34;, &#39;#73D723&#39;)], foreground=[(&#34;active&#34;, &#34;white&#34;)], font=[(&#34;active&#34;, (
            &#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))], padding=[(&#39;active&#39;, 20)])
        style.map(&#39;TButton&#39;, background=[(&#39;active&#39;, &#39;#73D723&#39;)])
        #  FIX tkinter tag_configure not showing colors   https://bugs.python.org/issue36468
        style.map(&#39;Treeview&#39;, foreground=Appli.fixedMap(&#39;foreground&#39;, style),
                  background=Appli.fixedMap(&#39;background&#39;, style))
        # Removed dashed line https://stackoverflow.com/questions/23354303/removing-ttk-notebook-tab-dashed-line/23399786
        style.layout(&#34;TNotebook.Tab&#34;,
                     [(&#39;Plain.Notebook.tab&#39;,
                       {&#39;children&#39;:[(&#39;Notebook.padding&#39;, {&#39;side&#39;: &#39;top&#39;, &#39;children&#39;: [(&#39;Notebook.label&#39;, {
                           &#39;side&#39;: &#39;top&#39;, &#39;sticky&#39;: &#39;&#39;})], &#39;sticky&#39;: &#39;nswe&#39;})],
                        &#39;sticky&#39;: &#39;nswe&#39;})])

    @staticmethod
    def fixedMap(option, style):
        &#34;&#34;&#34;
        Fix color tag in treeview not appearing under some linux distros
        Args:
            option: the string option you want to affect on treeview (&#34;background&#34; for example)
            strle: the style object of ttk
        &#34;&#34;&#34;
        # Fix for setting text colour for Tkinter 8.6.9
        # From: https://core.tcl.tk/tk/info/509cafafae
        #  FIX tkinter tag_configure not showing colors   https://bugs.python.org/issue36468
        # Returns the style map for &#39;option&#39; with any styles starting with
        # (&#39;!disabled&#39;, &#39;!selected&#39;, ...) filtered out.

        # style.map() returns an empty list for missing options, so this
        # should be future-safe.
        return [elm for elm in style.map(&#39;Treeview&#39;, query_opt=option) if
                elm[:2] != (&#39;!disabled&#39;, &#39;!selected&#39;)]


    def initMainView(self):
        &#34;&#34;&#34;
        Fill the main view tab menu
        &#34;&#34;&#34;
        self.mainPageFrame = ttk.Frame(self.nbk)
        searchFrame = ttk.Frame(self.mainPageFrame)
        lblSearch = ttk.Label(searchFrame, text=&#34;Filter bar:&#34;)
        lblSearch.pack(side=&#34;left&#34;, fill=tk.NONE)
        self.searchBar = AutocompleteEntry(self.settings, searchFrame, width=94)
        #self.searchBar = ttk.Entry(searchFrame, width=108)
        self.searchBar.bind(&#39;&lt;Return&gt;&#39;, self.newSearch)
        self.searchBar.bind(&#39;&lt;KP_Enter&gt;&#39;, self.newSearch)
        self.searchBar.bind(&#39;&lt;Control-a&gt;&#39;, self.searchbarSelectAll)
        # searchBar.bind(&#34;&lt;Button-3&gt;&#34;, self.do_popup)
        self.searchBar.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        btnSearchBar = ttk.Button(searchFrame, text=&#34;Search&#34;, command=self.newSearch)
        btnSearchBar.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        btnReset = ttk.Button(searchFrame, text=&#34;Reset&#34;,command=self.resetButtonClicked)
        btnReset.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.btnHelp = ttk.Button(searchFrame)
        self.photo = tk.PhotoImage(file=Utils.getHelpIconPath())
        self.helpFrame = None
        self.btnHelp.config(image=self.photo, command=self.showSearchHelp)
        self.btnHelp.pack(side=&#34;left&#34;)
        searchFrame.pack(side=&#34;top&#34;, fill=&#34;x&#34;)
        #PANED PART
        self.paned = tk.PanedWindow(self.mainPageFrame, height=800)
        #RIGHT PANE : Canvas + frame
        self.canvasMain = tk.Canvas(self.paned, bg=&#34;white&#34;)
        self.viewframe = ttk.Frame(self.canvasMain)
        #LEFT PANE : Treeview
        self.frameTw = ttk.Frame(self.paned)
        self.treevw = CalendarTreeview(self, self.frameTw)
        self.treevw.initUI()
        scbVSel = ttk.Scrollbar(self.frameTw,
                                orient=tk.VERTICAL,
                                command=self.treevw.yview)
        self.treevw.configure(yscrollcommand=scbVSel.set)
        self.treevw.grid(row=0, column=0, sticky=tk.NSEW)
        scbVSel.grid(row=0, column=1, sticky=tk.NS)
        self.paned.add(self.frameTw)
        self.myscrollbarMain = tk.Scrollbar(self.paned, orient=&#34;vertical&#34;, command=self.canvasMain.yview)
        self.myscrollbarMain.pack(side=&#34;right&#34;, fill=tk.BOTH)
        self.canvasMain.bind(&#39;&lt;Enter&gt;&#39;, self.boundToMousewheelMain)
        self.canvasMain.bind(&#39;&lt;Leave&gt;&#39;, self.unboundToMousewheelMain)
        self.canvasMain.pack(side=&#34;left&#34;)
        self.canvasMain.create_window((0, 0), window=self.viewframe, anchor=&#39;nw&#39;)
        self.viewframe.bind(&#34;&lt;Configure&gt;&#34;, self.scrollFrameMainFunc)
        self.canvasMain.configure(yscrollcommand=self.myscrollbarMain.set)
        self.paned.add(self.canvasMain)
        self.paned.pack(fill=tk.BOTH, expand=1)
        self.frameTw.rowconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.frameTw.columnconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.nbk.add(self.mainPageFrame, text=&#34;Main View &#34;, image=self.main_tab_img, compound=tk.TOP, sticky=&#39;nsew&#39;)
    
    def searchbarSelectAll(self, _event):
        &#34;&#34;&#34;
        Callback to select all the text in searchbar
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        self.searchBar.select_range(0, &#39;end&#39;)
        self.searchBar.icursor(&#39;end&#39;)
        return &#34;break&#34;

    def boundToMousewheel(self, _event):
        &#34;&#34;&#34;Called when the **command canvas** is on focus.
        Bind the command scrollbar button on linux to the command canvas
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        self.canvas.bind_all(&#34;&lt;Button-4&gt;&#34;, self._onMousewheelCommand)
        self.canvas.bind_all(&#34;&lt;Button-5&gt;&#34;, self._onMousewheelCommand)

    def unboundToMousewheel(self, _event):
        &#34;&#34;&#34;Called when the **command canvas** is unfocused.
        Unbind the command scrollbar button on linux to the command canvas
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        self.canvas.unbind_all(&#34;&lt;Button-4&gt;&#34;)
        self.canvas.unbind_all(&#34;&lt;Button-5&gt;&#34;)

    def boundToMousewheelMain(self, _event):
        &#34;&#34;&#34;Called when the **main view canvas** is focused.
        Bind the main view scrollbar button on linux to the main view canvas
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        self.canvas.bind_all(&#34;&lt;Button-4&gt;&#34;, self._onMousewheelMain)
        self.canvas.bind_all(&#34;&lt;Button-5&gt;&#34;, self._onMousewheelMain)

    def unboundToMousewheelMain(self, _event):
        &#34;&#34;&#34;Called when the **main view canvas** is unfocused.
        Unbind the main view scrollbar button on linux to the main view canvas
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        self.canvasMain.unbind_all(&#34;&lt;Button-4&gt;&#34;)
        self.canvasMain.unbind_all(&#34;&lt;Button-5&gt;&#34;)

    def _onMousewheelMain(self, event):
        &#34;&#34;&#34;Called when a scroll occurs. boundToMousewheelMain must be called first.
        Performs the scroll on the main canvas.
        Args:
            event: Holds info on scroll within event.delta and event.num&#34;&#34;&#34;
        if event.num == 5 or event.delta == -120:
            count = 1
        if event.num == 4 or event.delta == 120:
            count = -1
        self.canvasMain.yview_scroll(count, &#34;units&#34;)

    def _onMousewheelCommand(self, event):
        &#34;&#34;&#34;Called when a scroll occurs. boundToMousewheel must be called first.
        Performs the scroll on the command canvas.
        Args:
            event: Holds info on scroll within event.delta and event.num&#34;&#34;&#34;
        if event.num == 5 or event.delta == -120:
            count = 1
        if event.num == 4 or event.delta == 120:
            count = -1
        self.canvas.yview_scroll(count, &#34;units&#34;)

    def scrollFrameMainFunc(self, _event):
        &#34;&#34;&#34;make the main canvas scrollable&#34;&#34;&#34;
        self.canvasMain.configure(scrollregion=self.canvasMain.bbox(&#34;all&#34;), width=20, height=200)

    def scrollFrameFunc(self, _event):
        &#34;&#34;&#34;make the command canvas scrollable&#34;&#34;&#34;
        self.canvas.configure(scrollregion=self.canvas.bbox(&#34;all&#34;), width=20, height=200)

    def initCommandsView(self):
        &#34;&#34;&#34;Populate the command tab menu view frame with cool widgets&#34;&#34;&#34;
        self.commandsPageFrame = ttk.Frame(self.nbk)
        self.commandPaned = tk.PanedWindow(self.commandsPageFrame, height=800)
        self.commandsFrameTw = ttk.Frame(self.commandPaned)
        self.canvas = tk.Canvas(self.commandPaned, bg=&#34;white&#34;)
        self.commandsViewFrame = ttk.Frame(self.canvas)
        self.myscrollbarCommand = tk.Scrollbar(self.commandPaned, orient=&#34;vertical&#34;, command=self.canvas.yview)
        self.myscrollbarCommand.pack(side=&#34;right&#34;, fill=tk.BOTH)
        self.canvas.bind(&#39;&lt;Enter&gt;&#39;, self.boundToMousewheel)
        self.canvas.bind(&#39;&lt;Leave&gt;&#39;, self.unboundToMousewheel)
        self.canvas.pack(side=&#34;left&#34;)
        self.canvas.create_window((0, 0), window=self.commandsViewFrame, anchor=&#39;nw&#39;)
        self.commandsViewFrame.bind(&#34;&lt;Configure&gt;&#34;, self.scrollFrameFunc)
        self.canvas.configure(yscrollcommand=self.myscrollbarCommand.set)
        self.commandsTreevw = CommandsTreeview(self, self.commandsFrameTw)
        scbVSel = ttk.Scrollbar(self.commandsFrameTw,
                                orient=tk.VERTICAL,
                                command=self.commandsTreevw.yview)
        self.commandsTreevw.configure(yscrollcommand=scbVSel.set)
        self.commandsTreevw.grid(row=0, column=0, sticky=tk.NSEW)
        scbVSel.grid(row=0, column=1, sticky=tk.NS)
        self.commandPaned.add(self.commandsFrameTw)
        self.commandPaned.add(self.canvas)
        self.commandPaned.pack(fill=tk.BOTH, expand=1)
        self.commandsFrameTw.rowconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.commandsFrameTw.columnconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.nbk.bind(&#34;&lt;&lt;NotebookTabChanged&gt;&gt;&#34;, self.tabSwitch)
        self.nbk.add(self.commandsPageFrame, text=&#34;Commands&#34;, image=self.commands_tab_img, compound=tk.TOP)

    def showSearchHelp(self, _event=None):
        &#34;&#34;&#34;Called when the searchbar help button is clicked. Display a floating help window with examples
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.helpFrame is None:
            x, y = self.btnHelp.winfo_rootx(), self.btnHelp.winfo_rooty()
            self.helpFrame = FloatingHelpWindow(410, 400, x-380, y+40, self)
        else:
            self.helpFrame.destroy()
            self.helpFrame = None

    def tabSwitch(self, event):
        &#34;&#34;&#34;Called when the user click on the tab menu to switch tab. Add a behaviour before the tab switches.
        Args:
            event : hold informations to identify which tab was clicked.
        &#34;&#34;&#34;
        tabName = self.nbk.tab(self.nbk.select(), &#34;text&#34;).strip()
        self.searchBar.quit()
        if tabName == &#34;Commands&#34;:
            self.commandsTreevw.initUI()
        mongoInstance = MongoCalendar.getInstance()
        if not mongoInstance.hasACalendarOpen():
            opened = self.promptCalendarName()
            if opened is None:
                return
        if tabName == &#34;Scan&#34;:
            if mongoInstance.calendarName is not None:
                if mongoInstance.calendarName != &#34;&#34;:
                    if os.name != &#39;nt&#39;: # Disable on windows
                        # if self.scanManager is None:
                        #    self.scanManager = ScanManager(mongoInstance.calendarName, self.settings)
                        self.scanManager.initUI(self.scanViewFrame)
                    else:
                        lbl = ttk.Label(self.scanViewFrame, text=&#34;Disabled on windows because celery does not support it.&#34;)
                        lbl.pack()
        elif tabName == &#34;Summary&#34;:
            if mongoInstance.calendarName is not None:
                self.summary.refreshUI()
        elif tabName == &#34;Dashboard&#34;:
            if mongoInstance.calendarName is not None:
                self.dashboard.refreshUI()
        elif tabName == &#34;Settings&#34;:
            self.settings.reloadUI()
        elif tabName == &#34;Report&#34;:
            self.report.refreshUI()
        elif tabName == &#34;Terminal&#34;:
            mainDir = os.path.normpath(Utils.getMainDir())
            with open(os.path.join(mainDir, &#34;setupTerminalForPentest.sh&#34;), &#34;r&#34;) as f:
                data = f.read()
                lines = data.split(&#34;\n&#34;)
                lines[0] = &#34;POLLENISATOR_CURRENT_DB=&#34;+str(mongoInstance.calendarName)
                data = &#34;\n&#34;.join(lines)
                with open(os.path.join(mainDir, &#34;setupTerminalForPentest.sh&#34;), &#34;w&#34;) as f:
                    f.write(data)
            favorite = self.settings.getFavoriteTerm()
            if favorite is None:
                tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;None of the terminals given in the settings are installed on this computer.&#34;)
                self.nbk.select(0)
                return
            if which(favorite) is not None:
                terms = self.settings.getTerms()
                terms_dict = {}
                for term in terms:
                    terms_dict[term.split(&#34; &#34;)[0]] = term
                command_term = terms_dict.get(favorite, None)
                if command_term is not None:
                    Utils.execute(terms_dict[favorite])
                else:
                    tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;Check your terminal settings&#34;)
            else:
                tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;The selected favorite terminal is not available on this computer.&#34;)
            self.nbk.select(0)
        elif tabName == &#34;Dashboard&#34;:
            self.dashboard.refreshUI()
        event.widget.winfo_children()[event.widget.index(&#34;current&#34;)].update()

    def initSettingsView(self):
        &#34;&#34;&#34;Add the settings view frame to the notebook widget and initialize its UI.&#34;&#34;&#34;
        self.settingViewFrame = ttk.Frame(self.nbk)
        self.settings.initUI(self.settingViewFrame)
        self.settingViewFrame.pack(fill=tk.BOTH, expand=1)
        self.nbk.add(self.settingViewFrame, text=&#34;  Settings  &#34;, image=self.settings_tab_img, compound=tk.TOP)

    def initScanView(self):
        &#34;&#34;&#34;Add the scan view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.scanViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.scanViewFrame, text=&#34;    Scan     &#34;, image=self.scan_tab_img, compound=tk.TOP)

    def initReportView(self):
        &#34;&#34;&#34;Add the report view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.reportViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.reportViewFrame, text=&#34;   Report   &#34;, image=self.report_tab_img, compound=tk.TOP)

    def initSummaryView(self):
        &#34;&#34;&#34;Add the summary view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.summaryViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.summaryViewFrame, text=&#34; Summary &#34;, image=self.summary_tab_img, compound=tk.TOP)

    def initDashBoardView(self):
        &#34;&#34;&#34;Add the dashboard view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.dashboardViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.dashboardViewFrame, text = &#34;Dashboard&#34;,image=self.dashboard_tab_img,compound=tk.TOP)

    def initUI(self):
        &#34;&#34;&#34;
        initialize all the main windows objects. (Bar Menu, contextual menu, treeview, editing pane)
        &#34;&#34;&#34;
        self.nbk = ttk.Notebook(self.parent)
        self.statusbar = StatusBar(self.parent, Settings.getTags(), self)
        self.statusbar.pack(fill=tk.X)
        self.nbk.enable_traversal()
        self.initMainView()
        self.initDashBoardView()
        self.initSummaryView()
        self.initCommandsView()
        self.initScanView()
        self.initReportView()
        self.initSettingsView()
        self._initMenuBar()
        terminal_frame = ttk.Frame(self.nbk)
        self.nbk.add(terminal_frame, text=&#34;  Terminal  &#34;, image=self.terminal_tab_img, compound=tk.TOP)
        self.nbk.pack(fill=tk.BOTH, expand=1)

    def newSearch(self, _event=None):
        &#34;&#34;&#34;Called when the searchbar is validated (click on search button or enter key pressed).
        Perform a filter on the main treeview.
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        filterStr = self.searchBar.get()
        self.settings.reloadSettings()
        success = self.treevw.filterTreeview(filterStr, self.settings)
        self.searchMode = (success and filterStr.strip() != &#34;&#34;)
        if success:
            histo_filters = self.settings.local_settings.get(&#34;histo_filters&#34;, [])
            if filterStr.strip() != &#34;&#34;:
                histo_filters.insert(0, filterStr)
                if len(histo_filters) &gt; 10:
                    histo_filters = histo_filters[:10]
                self.settings.local_settings[&#34;histo_filters&#34;] = histo_filters
                self.settings.saveLocalSettings()
            if self.helpFrame is not None:
                self.helpFrame.destroy()
                self.helpFrame = None

    def statusbarClicked(self, name):
        &#34;&#34;&#34;Called when a button in the statusbar tag is clicked.
        filter the treeview to match the status bar tag clicked and enforce select of main view
        Args:
            name: not used but mandatory&#34;&#34;&#34;
        # get the index of the mouse click
        self.nbk.select(0)
        self.searchMode = True
        self.treevw.filterTreeview(&#34;\&#34;&#34;+name+&#34;\&#34; in tags&#34;)

    def resetButtonClicked(self):
        &#34;&#34;&#34;
        Called when the reset button of the status bar is clicked.
        &#34;&#34;&#34;
        self.searchMode = False
        self.searchBar.reset()
        self.treevw.unfilter()

    def refreshView(self, _event=None):
        &#34;&#34;&#34;
        Reload the currently opened tab
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        setViewOn = None
        nbkOpenedTab = self.nbk.tab(self.nbk.select(), &#34;text&#34;).strip()
        activeTw = None
        if nbkOpenedTab == &#34;Main View&#34;:
            activeTw = self.treevw
        elif nbkOpenedTab == &#34;Commands&#34;:
            activeTw = self.commandsTreevw
        elif nbkOpenedTab == &#34;Scan&#34;:
            self.scanManager.initUI(self.scanViewFrame)
        elif nbkOpenedTab == &#34;Summary&#34;:
            self.summary.refreshUI()
        elif nbkOpenedTab == &#34;Settings&#34;:
            self.settings.reloadUI()
        elif nbkOpenedTab == &#34;Report&#34;:
            self.report.refreshUI()
        elif nbkOpenedTab == &#34;Dashboard&#34;:
            self.dashboard.refreshUI()
        if activeTw is not None:
            if len(activeTw.selection()) == 1:
                setViewOn = activeTw.selection()[0]
            activeTw.refresh()
        if setViewOn is not None:
            try:
                activeTw.see(setViewOn)
                activeTw.focus(setViewOn)
                activeTw.selection_set(setViewOn)
                activeTw.openModifyWindowOf(setViewOn)
            except tk.TclError:
                pass

    def resetUnfinishedTools(self):
        &#34;&#34;&#34;
        Reset all running tools to a ready state.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        if mongoInstance.hasACalendarOpen():
            Utils.resetUnfinishedTools()
            self.treevw.load()

    def exportCalendar(self):
        &#34;&#34;&#34;
        Dump a pentest database to an archive file gunzip.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        dialog = ChildDialogCombo(self, mongoInstance.listCalendars()[::-1], &#34;Choose a database to dump:&#34;)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, str):
            mongoInstance.dumpDb(dialog.rvalue)

    def exportCommands(self):
        &#34;&#34;&#34;
        Dump pollenisator from database to an archive file gunzip.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.dumpDb(&#34;pollenisator&#34;, &#34;commands&#34;)
        mongoInstance.dumpDb(&#34;pollenisator&#34;, &#34;group_commands&#34;)
        tkinter.messagebox.showinfo(
            &#34;Export pollenisator database&#34;, &#34;Export completed in exports/pollenisator_commands.gzip and exports/pollenisator_group_commands.gzip&#34;)

    def importCalendar(self, name=None):
        &#34;&#34;&#34;
        Import a calendar archive file gunzip to database.
        Args:
            name: The filename of the gunzip database exported previously
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        filename = &#34;&#34;
        if name is None:
            f = tkinter.filedialog.askopenfilename(defaultextension=&#34;.gzip&#34;)
            if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
                return
            filename = str(f)
        else:
            filename = name
        mongoInstance.importDatabase(filename)

    def importCommands(self, name=None):
        &#34;&#34;&#34;
        Import a pollenisator archive file gunzip to database.
        Args:
            name: The filename of the gunzip command table exported previously
        Returns:
            None if name is None and filedialog is closed
            True if commands successfully are imported
            False otherwise.
        &#34;&#34;&#34;
        filename = &#34;&#34;
        if name is None:
            f = tkinter.filedialog.askopenfilename(defaultextension=&#34;.gzip&#34;)
            if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
                return
            filename = str(f)
        else:
            filename = name
        try:
            mongoInstance = MongoCalendar.getInstance()
            mongoInstance.importCommands(filename)
            self.commandsTreevw.refresh()
        except IOError:
            tkinter.messagebox.showerror(
                &#34;Import commands&#34;, &#34;Import failed. &#34;+str(filename)+&#34; was not found or is not a file.&#34;)
            return False
        tkinter.messagebox.showinfo(
            &#34;Import commands&#34;, &#34;Import of &#34;+filename+&#34; completed&#34;)
        return True

    def onExit(self):
        &#34;&#34;&#34;
        Exit the application
        &#34;&#34;&#34;
        self.onClosing()

    def promptCalendarName(self, _event=None):
        &#34;&#34;&#34;
        Ask a user to select an pentest database including a New database option.
        Args:
            _event: Not used but mandatory
        Returns:
            None if no database were selected
            datababase name otherwise
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        calendars = mongoInstance.listCalendars()
        if calendars is None:
            calendars = []
        dialog = ChildDialogCombo(self, [&#34;New database&#34;]+calendars[::-1], &#34;Please select a database&#34;)
        self.wait_window(dialog.app)
        if dialog.rvalue is None:
            return None
        if isinstance(dialog.rvalue, str):
            if dialog.rvalue == &#34;New database&#34;:
                self.selectNewCalendar()
            else:
                self.openCalendar(dialog.rvalue)
            return dialog.rvalue

    def deleteACalendar(self):
        &#34;&#34;&#34;
        Ask a user a calendar name then delete it.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        dialog = ChildDialogCombo(
            self, mongoInstance.listCalendars()[::-1], &#34;Choose a database to delete:&#34;)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, str):
            calendarName = dialog.rvalue
            ret = tkinter.messagebox.askokcancel(
                &#34;Delete tools on server&#34;, &#34;Do you also want to delete resulting tool files on server sftp ?&#34;)
            if ret:
                self.removeFiles(calendarName)

            ret = tkinter.messagebox.askokcancel(
                &#34;The document will be deleted&#34;, &#34;You are going to delete permanently the database \&#34;&#34;+calendarName+&#34;\&#34;. Are you sure ?&#34;)
            if ret:
                mongoInstance.doDeleteCalendar(calendarName)

            self.treevw.deleteState(calendarName)

    def newCalendar(self, calendarName):
        &#34;&#34;&#34;
        Register the given calendar name into database and opens it.

        Args:
            calendarName: The pentest database name to register in database.
        &#34;&#34;&#34;
        succeed = False
        if calendarName is not None:
            mongoInstance = MongoCalendar.getInstance()
            succeed = mongoInstance.registerCalendar(calendarName, True, True)
        return succeed

    def selectNewCalendar(self):
        &#34;&#34;&#34;
        Ask a user for a new calendar name. Then creates it.
        &#34;&#34;&#34;
        validCalendar = False
        default = {}
        while not validCalendar:
            dialog = ChildDialogNewCalendar(self.parent, default)
            self.wait_window(dialog.app)
            if isinstance(dialog.rvalue, dict):
                default = dialog.rvalue
                dbName = dialog.rvalue[&#34;name&#34;]
                pentest_type = dialog.rvalue[&#34;type&#34;]
                start_date = dialog.rvalue[&#34;start&#34;]
                end_date = dialog.rvalue[&#34;end&#34;]
                scope = dialog.rvalue[&#34;scope&#34;]
                settings = dialog.rvalue[&#34;settings&#34;]
                pentesters = dialog.rvalue[&#34;pentesters&#34;]
                validCalendar = self.newCalendar(dbName)
                if validCalendar:
                    self.openCalendar(dbName)
                    dialog = ChildDialogInfo(
                         self.parent, &#34;New database created&#34;, &#34;Database setup ...&#34;)
                    dialog.show()
                    self.prepareCalendar(dbName, pentest_type, start_date, end_date, scope, settings, pentesters)
                    dialog.destroy()


            else:
                return
            

    def prepareCalendar(self, dbName, pentest_type, start_date, end_date, scope, settings, pentesters):
        &#34;&#34;&#34;
        Initiate a pentest database with wizard info
        Args:
            dbName: the database name
            pentest_type: a pentest type choosen from settings pentest_types. Used to select commands that will be launched by default
            start_date: a begining date and time for the pentest
            end_date: ending date and time for the pentest
            scope: a list of scope valid string (IP, network IP or host name)
            settings: a dict of settings with keys:
                * &#34;Add domains whose IP are in scope&#34;: if 1, will do a dns lookup on new domains and check if found IP is in scope
                * &#34;Add domains who have a parent domain in scope&#34;: if 1, will add a new domain if a parent domain is in scope
                * &#34;Add all domains found&#34;:  Unsafe. if 1, all new domains found by tools will be considered in scope.
        &#34;&#34;&#34;
        commands = Command.getList({&#34;$or&#34;:[{&#34;types&#34;:{&#34;$elemMatch&#34;:{&#34;$eq&#34;:pentest_type}}}, {&#34;types&#34;:{&#34;$elemMatch&#34;:{&#34;$eq&#34;:&#34;Commun&#34;}}}]})
        if not commands:
            commandslist = Command.getList()
            if not commandslist:
                dialog = ChildDialogQuestion(self.parent, &#34;No command found&#34;, &#34;There is no registered command in the database. Would you like to import the default set?&#34;)
                self.parent.wait_window(dialog.app)
                if dialog.rvalue != &#34;Yes&#34;:
                    return
                default = os.path.join(Utils.getMainDir(), &#34;exports/pollenisator_commands.gzip&#34;)
                res = self.importCommands(default)
                if res:
                    default = os.path.join(Utils.getMainDir(), &#34;exports/pollenisator_group_commands.gzip&#34;)
                    res = self.importCommands(default)
        Wave().initialize(dbName, commands).addInDb()
        Interval().initialize(dbName, start_date, end_date).addInDb()
        values = {&#34;wave&#34;:dbName, &#34;Scopes&#34;:scope, &#34;Settings&#34;:False}
        ScopeController(Scope()).doInsert(values)
        self.settings.reloadSettings()
        self.settings.db_settings[&#34;pentest_type&#34;] = pentest_type
        self.settings.db_settings[&#34;include_domains_with_ip_in_scope&#34;] = settings[&#39;Add domains whose IP are in scope&#39;] == 1
        self.settings.db_settings[&#34;include_domains_with_topdomain_in_scope&#34;] = settings[&#34;Add domains who have a parent domain in scope&#34;] == 1
        self.settings.db_settings[&#34;include_all_domains&#34;] = settings[&#34;Add all domains found&#34;] == 1
        self.settings.db_settings[&#34;pentesters&#34;] = list(map(lambda x: x.strip(), pentesters.split(&#34;\n&#34;)))
        self.settings.save()

    def openCalendar(self, filename=&#34;&#34;):
        &#34;&#34;&#34;
        Open the given database name. Loads it in treeview.

        Args:
            filename: the pentest database name to load in application. If &#34;&#34; is given (default), will refresh the already opened database if there is one.
        &#34;&#34;&#34;
        print(&#34;Start monitoring&#34;)
        calendarName = None
        mongoInstance = MongoCalendar.getInstance()
        if filename == &#34;&#34; and mongoInstance.hasACalendarOpen():
            calendarName = mongoInstance.calendarName
        elif filename != &#34;&#34;:
            calendarName = filename.split(&#34;.&#34;)[0].split(&#34;/&#34;)[-1]
        if calendarName is not None:
            if self.scanManager is not None:
                self.scanManager.stop()
            if self.notifications_timers is not None:
                self.notifications_timers.cancel()
                self.notifications_timers = None
            mongoInstance.connectToDb(calendarName)
            for widget in self.viewframe.winfo_children():
                widget.destroy()
            self.report.initUI(self.reportViewFrame)
            self.summary.initUI(self.summaryViewFrame, self.nbk, self.treevw)
            self.dashboard.initUI(self.dashboardViewFrame)
            self.statusbar.reset()
            self.treevw.refresh()
            if os.name != &#34;nt&#34;: # On windows celery 4.X is not managed
                self.scanManager = ScanManager(self.nbk, self.treevw, mongoInstance.calendarName, self.settings)
                self.notifications_timers = threading.Timer(
                    0.5, self.readNotifications)
                self.notifications_timers.start()

    def wrapCopyDb(self, _event=None):
        &#34;&#34;&#34;
        Call default copy database from a callback event.

        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.copyDb()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Pollenisator.core.Application.Appli.Appli"><code class="flex name class">
<span>class <span class="ident">Appli</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Main tkinter graphical application object.</p>
<p>Initialise the application</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>The main tk window.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Appli(ttk.Frame):
    &#34;&#34;&#34;
    Main tkinter graphical application object.
    &#34;&#34;&#34;

    def __init__(self, parent):
        &#34;&#34;&#34;
        Initialise the application

        Args:
            parent: The main tk window.
        &#34;&#34;&#34;
        # Lexic:
        # view frame : the frame in the tab that will hold forms.
        # Tree view : the tree on the left of the window.
        # frame tree view : a frame around the tree view (useful to attach a scrollbar to a treeview)
        # canvas : a canvas object (useful to attach a scrollbar to a frame)
        # paned : a Paned widget is used to separate two other widgets and display a one over the other if desired
        #           Used to separate the treeview frame and view frame.
        
        self.parent = parent  #  parent tkinter window
        #  already read notifications from previous notification reading iteration
        self.old_notifs = []
        self.notifications_timers = None
        tk.Tk.report_callback_exception = self.show_error
        self.setStyle()
        # HISTORY : Main view and command where historically in the same view;
        # This results in lots of widget here with a confusing naming style
        ttk.Frame.__init__(self, parent)
        #### core components (Tab menu on the left objects)####
        self.settings = Settings()
        self.settingViewFrame = None
        self.dashboard = DashBoard()
        self.dashboardViewFrame = None
        self.report = Report(self.settings)
        self.reportViewFrame = None
        self.summary = Summary(self.parent)
        self.summaryViewFrame = None
        self.scanManager = None  #  Loaded when clicking on it if linux only
        self.scanViewFrame = None
        # Icons for each tab menu
        self.dashboard_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_dashboard.png&#34;))
        self.main_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_main.png&#34;))
        self.commands_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_commands.png&#34;))
        self.scan_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_scan.png&#34;))
        self.settings_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_settings.png&#34;))
        self.summary_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_summary.png&#34;))
        self.report_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_report.png&#34;))
        self.terminal_tab_img = ImageTk.PhotoImage(
            Image.open(Utils.getIconDir()+&#34;tab_terminal.png&#34;))
        
        #### MAIN VIEW ####
        self.openedViewFrameId = None
        self.mainPageFrame = None
        self.paned = None
        self.canvasMain = None
        self.viewframe = None
        self.frameTw = None
        self.treevw = None
        self.myscrollbarMain = None
        #### COMMAND VIEW ####
        self.commandsPageFrame = None
        self.commandPaned = None
        self.commandsFrameTw = None
        self.canvas = None
        self.commandsViewFrame = None
        self.myscrollbarCommand = None
        self.commandsTreevw = None
        #### SEARCH BAR ####
        # boolean set to true when the main tree view is displaying search results
        self.searchMode = False
        self.searchBar = None  # the search bar component
        self.btnHelp = None  # help button on the right of the search bar
        self.photo = None  # the ? image
        self.helpFrame = None  # the floating help frame poping when the button is pressed

        # Connect to database and choose database to open
        abandon = False
        mongoInstance = MongoCalendar.getInstance()
        while not mongoInstance.isUserConnected() and not abandon:
            abandon = self.promptForConnection() is None
        if not abandon:
            mongoInstance.attach(self)
            self.initUI()
            # Will trigger promptForCalendarOpen when tab will be opened
        else:
            self.onClosing()
            parent.destroy()

    def show_error(self, *args):
        &#34;&#34;&#34;Callback for tk.Tk.report_callback_exception.
        Open a window to display exception with some actions possible

        Args:
            args: 3 args are required for tk.Tk.report_callback_exception event to be given to traceback.format_exception(args[0], args[1], args[2])
        
        Raises:
            If an exception occurs in this handler thread, will print it and exit with exit code 1
        &#34;&#34;&#34;
        try:
            err = traceback.format_exception(args[0], args[1], args[2])
            dialog = ChildDialogException(self, &#39;Exception occured&#39;, err)
            self.wait_window(dialog.app)
        except Exception as e:
            print(e)
            sys.exit(1)

    def promptForConnection(self):
        &#34;&#34;&#34;Close current database connection and open connection form for the user
        
        Returns: 
            The number of pollenisator database found, 0 if the connection failed.&#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.reinitConnection()
        connectDialog = ChildDialogConnect(self.parent)
        self.wait_window(connectDialog.app)
        return connectDialog.rvalue

    def getCentralizedFiles(self):
        &#34;&#34;&#34;Download from SFTP server all files of current database in local directory
        &#34;&#34;&#34;
        fs = FileStorage()
        fs.open()
        fs.getResults()
        fs.close()
        tkinter.messagebox.showinfo(
            &#34;Centralization completed&#34;, &#34;Files were download in results/&#34;)

    def submitIssue(self):
        &#34;&#34;&#34;Open git issues in browser&#34;&#34;&#34;
        import webbrowser
        webbrowser.open_new_tab(&#34;https://github.com/AlgoSecure/Pollenisator/issues&#34;)

    def removeFiles(self, calendarName):
        &#34;&#34;&#34;Open git issues in browser
        Args:
            calendarName: database name to be removed.
        &#34;&#34;&#34;
        fs = FileStorage()
        fs.open()
        fs.rmDbResults(calendarName.strip())
        fs.rmDbProofs(calendarName.strip())
        fs.close()
        tkinter.messagebox.showinfo(
            &#34;Deleting tool&#34;, &#34;Files were removed on sftp for &#34;+str(calendarName))

    def readNotifications(self):
        &#34;&#34;&#34;
        Read notifications from database every 0.5 or so second. Notifications are used to exchange informations between applications.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        for old_notif in self.old_notifs:
            mongoInstance.deleteFromDb(&#34;pollenisator&#34;, &#34;notifications&#34;, {&#34;_id&#34;: old_notif})
        self.old_notifs = []
        try:
            notifications = mongoInstance.findInDb(&#34;pollenisator&#34;, &#34;notifications&#34;, {&#34;$or&#34;:[{&#34;db&#34;:str(mongoInstance.calendarName)}, {&#34;db&#34;:&#34;pollenisator&#34;}]})
            for notification in notifications:
                # print(&#34;Notification received &#34;+str(notification[&#34;db&#34;])+&#34;/&#34;+str(notification[&#34;collection&#34;])+&#34; iid=&#34;+str(notification[&#34;iid&#34;])+&#34; action=&#34;+str(notification[&#34;action&#34;]))
                self.old_notifs.append(notification[&#34;_id&#34;])
                if notification[&#34;db&#34;] == &#34;pollenisator&#34;:
                    if notification[&#34;collection&#34;] == &#34;workers&#34;:
                        self.scanManager.notify(notification[&#34;iid&#34;], notification[&#34;action&#34;])
                    elif &#34;commands&#34; in notification[&#34;collection&#34;]:
                        self.commandsTreevw.notify(notification[&#34;db&#34;], notification[&#34;collection&#34;], notification[&#34;iid&#34;], notification[&#34;action&#34;], notification.get(&#34;parent&#34;, &#34;&#34;))
                else:
                    self.treevw.notify(notification[&#34;db&#34;], notification[&#34;collection&#34;],
                                    notification[&#34;iid&#34;], notification[&#34;action&#34;], notification.get(&#34;parent&#34;, &#34;&#34;))
        except Exception as e:
            print(str(e))
        self.notifications_timers = threading.Timer(
            0.5, self.readNotifications)
        self.notifications_timers.start()

    def onClosing(self):
        &#34;&#34;&#34;
        Close the application properly.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.dettach(self)
        if self.scanManager is not None:
            self.scanManager.stop()
        print(&#34;Stopping notifications...&#34;)
        if self.notifications_timers is not None:
            self.notifications_timers.cancel()
        if self.scanManager is not None:
            self.scanManager.monitor.stopWorkersTimer()
        print(&#34;Stopping application...&#34;)
        self.quit()

    def _initMenuBar(self):
        &#34;&#34;&#34;
        Create the bar menu on top of the screen.
        &#34;&#34;&#34;
        menubar = tk.Menu(self.parent, tearoff=0, bd=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        self.parent.config(menu=menubar)

        self.parent.bind(&#39;&lt;F5&gt;&#39;, self.refreshView)
        self.parent.bind(&#39;&lt;Control-o&gt;&#39;, self.promptCalendarName)
        fileMenu = tk.Menu(menubar, tearoff=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        fileMenu.add_command(label=&#34;New&#34;, command=self.selectNewCalendar)
        fileMenu.add_command(label=&#34;Open (Ctrl+o)&#34;,
                             command=self.promptCalendarName)
        fileMenu.add_command(label=&#34;Connect to server&#34;, command=self.promptForConnection)
        fileMenu.add_command(label=&#34;Copy&#34;, command=self.wrapCopyDb)
        fileMenu.add_command(label=&#34;Delete a database&#34;,
                             command=self.deleteACalendar)
        fileMenu.add_command(label=&#34;Export database&#34;,
                             command=self.exportCalendar)
        fileMenu.add_command(label=&#34;Import database&#34;,
                             command=self.importCalendar)
        fileMenu.add_command(label=&#34;Export commands&#34;,
                             command=self.exportCommands)
        fileMenu.add_command(label=&#34;Import commands&#34;,
                             command=self.importCommands)

        fileMenu.add_command(label=&#34;Exit&#34;, command=self.onExit)
        fileMenu2 = tk.Menu(menubar, tearoff=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        fileMenu2.add_command(label=&#34;Reset unfinished tools&#34;,
                              command=self.resetUnfinishedTools)
        fileMenu2.add_command(label=&#34;Refresh (F5)&#34;,
                              command=self.refreshView)
        fileMenu2.add_command(label=&#34;Get centralized files&#34;,
                              command=self.getCentralizedFiles)
        fileMenu3 = tk.Menu(menubar, tearoff=0, background=&#39;#73B723&#39;, foreground=&#39;white&#39;, activebackground=&#39;#73B723&#39;, activeforeground=&#39;white&#39;)
        fileMenu3.add_command(label=&#34;Submit a bug or feature&#34;,
                              command=self.submitIssue)
        menubar.add_cascade(label=&#34;File&#34;, menu=fileMenu)
        menubar.add_cascade(label=&#34;Scans&#34;, menu=fileMenu2)
        menubar.add_cascade(label=&#34;Help&#34;, menu=fileMenu3)

    def setStyle(self, _event=None):
        &#34;&#34;&#34;
        Set the pollenisator window widget style using ttk.Style
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        style = ttk.Style(self.parent)
        style.theme_use(&#34;clam&#34;)
        try:
            style.element_create(&#39;Plain.Notebook.tab&#39;, &#34;from&#34;, &#39;default&#39;)
        except TclError:
            pass # ALready exists
        style.configure(&#34;Treeview.Heading&#34;, background=&#34;#73B723&#34;,
                        foreground=&#34;white&#34;, relief=&#34;flat&#34;)
        style.map(&#39;Treeview.Heading&#39;, background=[(&#39;active&#39;, &#39;#73B723&#39;)])
        style.configure(&#34;TLabelframe&#34;, background=&#34;white&#34;,
                        labeloutside=False, bordercolor=&#34;#73B723&#34;)
        style.configure(&#39;TLabelframe.Label&#39;, background=&#34;#73B723&#34;,
                        foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))
        style.configure(&#34;TProgressbar&#34;,
                        background=&#34;#73D723&#34;, foreground=&#34;#73D723&#34;, troughcolor=&#34;white&#34;, darkcolor=&#34;#73D723&#34;, lightcolor=&#34;#73D723&#34;)
        style.configure(&#34;Important.TFrame&#34;, background=&#34;#73B723&#34;)
        style.configure(&#34;TFrame&#34;, background=&#34;white&#34;)
        style.configure(&#34;Important.TLabel&#34;, background=&#34;#73B723&#34;, foreground=&#34;white&#34;)
        style.configure(&#34;TLabel&#34;, background=&#34;white&#34;)
        style.configure(&#34;TCombobox&#34;, background=&#34;white&#34;)
        style.configure(&#34;TCheckbutton&#34;, background=&#34;white&#34;,
                        font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))
        style.configure(&#34;TButton&#34;, background=&#34;#73B723&#34;,
                        foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), borderwidth=1)
        style.configure(&#34;TNotebook&#34;, background=&#34;#73B723&#34;, foreground=&#34;white&#34;, font=(
            &#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), tabposition=&#39;wn&#39;, borderwidth=0, width=100)

        style.configure(&#34;TNotebook.Tab&#34;, background=&#34;#73B723&#34;, borderwidth=0,
                        foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), padding=20, bordercolor=&#34;#73B723&#34;)
        style.map(&#39;TNotebook.Tab&#39;, background=[(&#39;active&#39;, &#39;#73C723&#39;), (&#34;selected&#34;, &#39;#73D723&#39;)], foreground=[(&#34;active&#34;, &#34;white&#34;)], font=[(&#34;active&#34;, (
            &#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))], padding=[(&#39;active&#39;, 20)])
        style.map(&#39;TButton&#39;, background=[(&#39;active&#39;, &#39;#73D723&#39;)])
        #  FIX tkinter tag_configure not showing colors   https://bugs.python.org/issue36468
        style.map(&#39;Treeview&#39;, foreground=Appli.fixedMap(&#39;foreground&#39;, style),
                  background=Appli.fixedMap(&#39;background&#39;, style))
        # Removed dashed line https://stackoverflow.com/questions/23354303/removing-ttk-notebook-tab-dashed-line/23399786
        style.layout(&#34;TNotebook.Tab&#34;,
                     [(&#39;Plain.Notebook.tab&#39;,
                       {&#39;children&#39;:[(&#39;Notebook.padding&#39;, {&#39;side&#39;: &#39;top&#39;, &#39;children&#39;: [(&#39;Notebook.label&#39;, {
                           &#39;side&#39;: &#39;top&#39;, &#39;sticky&#39;: &#39;&#39;})], &#39;sticky&#39;: &#39;nswe&#39;})],
                        &#39;sticky&#39;: &#39;nswe&#39;})])

    @staticmethod
    def fixedMap(option, style):
        &#34;&#34;&#34;
        Fix color tag in treeview not appearing under some linux distros
        Args:
            option: the string option you want to affect on treeview (&#34;background&#34; for example)
            strle: the style object of ttk
        &#34;&#34;&#34;
        # Fix for setting text colour for Tkinter 8.6.9
        # From: https://core.tcl.tk/tk/info/509cafafae
        #  FIX tkinter tag_configure not showing colors   https://bugs.python.org/issue36468
        # Returns the style map for &#39;option&#39; with any styles starting with
        # (&#39;!disabled&#39;, &#39;!selected&#39;, ...) filtered out.

        # style.map() returns an empty list for missing options, so this
        # should be future-safe.
        return [elm for elm in style.map(&#39;Treeview&#39;, query_opt=option) if
                elm[:2] != (&#39;!disabled&#39;, &#39;!selected&#39;)]


    def initMainView(self):
        &#34;&#34;&#34;
        Fill the main view tab menu
        &#34;&#34;&#34;
        self.mainPageFrame = ttk.Frame(self.nbk)
        searchFrame = ttk.Frame(self.mainPageFrame)
        lblSearch = ttk.Label(searchFrame, text=&#34;Filter bar:&#34;)
        lblSearch.pack(side=&#34;left&#34;, fill=tk.NONE)
        self.searchBar = AutocompleteEntry(self.settings, searchFrame, width=94)
        #self.searchBar = ttk.Entry(searchFrame, width=108)
        self.searchBar.bind(&#39;&lt;Return&gt;&#39;, self.newSearch)
        self.searchBar.bind(&#39;&lt;KP_Enter&gt;&#39;, self.newSearch)
        self.searchBar.bind(&#39;&lt;Control-a&gt;&#39;, self.searchbarSelectAll)
        # searchBar.bind(&#34;&lt;Button-3&gt;&#34;, self.do_popup)
        self.searchBar.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        btnSearchBar = ttk.Button(searchFrame, text=&#34;Search&#34;, command=self.newSearch)
        btnSearchBar.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        btnReset = ttk.Button(searchFrame, text=&#34;Reset&#34;,command=self.resetButtonClicked)
        btnReset.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.btnHelp = ttk.Button(searchFrame)
        self.photo = tk.PhotoImage(file=Utils.getHelpIconPath())
        self.helpFrame = None
        self.btnHelp.config(image=self.photo, command=self.showSearchHelp)
        self.btnHelp.pack(side=&#34;left&#34;)
        searchFrame.pack(side=&#34;top&#34;, fill=&#34;x&#34;)
        #PANED PART
        self.paned = tk.PanedWindow(self.mainPageFrame, height=800)
        #RIGHT PANE : Canvas + frame
        self.canvasMain = tk.Canvas(self.paned, bg=&#34;white&#34;)
        self.viewframe = ttk.Frame(self.canvasMain)
        #LEFT PANE : Treeview
        self.frameTw = ttk.Frame(self.paned)
        self.treevw = CalendarTreeview(self, self.frameTw)
        self.treevw.initUI()
        scbVSel = ttk.Scrollbar(self.frameTw,
                                orient=tk.VERTICAL,
                                command=self.treevw.yview)
        self.treevw.configure(yscrollcommand=scbVSel.set)
        self.treevw.grid(row=0, column=0, sticky=tk.NSEW)
        scbVSel.grid(row=0, column=1, sticky=tk.NS)
        self.paned.add(self.frameTw)
        self.myscrollbarMain = tk.Scrollbar(self.paned, orient=&#34;vertical&#34;, command=self.canvasMain.yview)
        self.myscrollbarMain.pack(side=&#34;right&#34;, fill=tk.BOTH)
        self.canvasMain.bind(&#39;&lt;Enter&gt;&#39;, self.boundToMousewheelMain)
        self.canvasMain.bind(&#39;&lt;Leave&gt;&#39;, self.unboundToMousewheelMain)
        self.canvasMain.pack(side=&#34;left&#34;)
        self.canvasMain.create_window((0, 0), window=self.viewframe, anchor=&#39;nw&#39;)
        self.viewframe.bind(&#34;&lt;Configure&gt;&#34;, self.scrollFrameMainFunc)
        self.canvasMain.configure(yscrollcommand=self.myscrollbarMain.set)
        self.paned.add(self.canvasMain)
        self.paned.pack(fill=tk.BOTH, expand=1)
        self.frameTw.rowconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.frameTw.columnconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.nbk.add(self.mainPageFrame, text=&#34;Main View &#34;, image=self.main_tab_img, compound=tk.TOP, sticky=&#39;nsew&#39;)
    
    def searchbarSelectAll(self, _event):
        &#34;&#34;&#34;
        Callback to select all the text in searchbar
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        self.searchBar.select_range(0, &#39;end&#39;)
        self.searchBar.icursor(&#39;end&#39;)
        return &#34;break&#34;

    def boundToMousewheel(self, _event):
        &#34;&#34;&#34;Called when the **command canvas** is on focus.
        Bind the command scrollbar button on linux to the command canvas
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        self.canvas.bind_all(&#34;&lt;Button-4&gt;&#34;, self._onMousewheelCommand)
        self.canvas.bind_all(&#34;&lt;Button-5&gt;&#34;, self._onMousewheelCommand)

    def unboundToMousewheel(self, _event):
        &#34;&#34;&#34;Called when the **command canvas** is unfocused.
        Unbind the command scrollbar button on linux to the command canvas
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        self.canvas.unbind_all(&#34;&lt;Button-4&gt;&#34;)
        self.canvas.unbind_all(&#34;&lt;Button-5&gt;&#34;)

    def boundToMousewheelMain(self, _event):
        &#34;&#34;&#34;Called when the **main view canvas** is focused.
        Bind the main view scrollbar button on linux to the main view canvas
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        self.canvas.bind_all(&#34;&lt;Button-4&gt;&#34;, self._onMousewheelMain)
        self.canvas.bind_all(&#34;&lt;Button-5&gt;&#34;, self._onMousewheelMain)

    def unboundToMousewheelMain(self, _event):
        &#34;&#34;&#34;Called when the **main view canvas** is unfocused.
        Unbind the main view scrollbar button on linux to the main view canvas
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        self.canvasMain.unbind_all(&#34;&lt;Button-4&gt;&#34;)
        self.canvasMain.unbind_all(&#34;&lt;Button-5&gt;&#34;)

    def _onMousewheelMain(self, event):
        &#34;&#34;&#34;Called when a scroll occurs. boundToMousewheelMain must be called first.
        Performs the scroll on the main canvas.
        Args:
            event: Holds info on scroll within event.delta and event.num&#34;&#34;&#34;
        if event.num == 5 or event.delta == -120:
            count = 1
        if event.num == 4 or event.delta == 120:
            count = -1
        self.canvasMain.yview_scroll(count, &#34;units&#34;)

    def _onMousewheelCommand(self, event):
        &#34;&#34;&#34;Called when a scroll occurs. boundToMousewheel must be called first.
        Performs the scroll on the command canvas.
        Args:
            event: Holds info on scroll within event.delta and event.num&#34;&#34;&#34;
        if event.num == 5 or event.delta == -120:
            count = 1
        if event.num == 4 or event.delta == 120:
            count = -1
        self.canvas.yview_scroll(count, &#34;units&#34;)

    def scrollFrameMainFunc(self, _event):
        &#34;&#34;&#34;make the main canvas scrollable&#34;&#34;&#34;
        self.canvasMain.configure(scrollregion=self.canvasMain.bbox(&#34;all&#34;), width=20, height=200)

    def scrollFrameFunc(self, _event):
        &#34;&#34;&#34;make the command canvas scrollable&#34;&#34;&#34;
        self.canvas.configure(scrollregion=self.canvas.bbox(&#34;all&#34;), width=20, height=200)

    def initCommandsView(self):
        &#34;&#34;&#34;Populate the command tab menu view frame with cool widgets&#34;&#34;&#34;
        self.commandsPageFrame = ttk.Frame(self.nbk)
        self.commandPaned = tk.PanedWindow(self.commandsPageFrame, height=800)
        self.commandsFrameTw = ttk.Frame(self.commandPaned)
        self.canvas = tk.Canvas(self.commandPaned, bg=&#34;white&#34;)
        self.commandsViewFrame = ttk.Frame(self.canvas)
        self.myscrollbarCommand = tk.Scrollbar(self.commandPaned, orient=&#34;vertical&#34;, command=self.canvas.yview)
        self.myscrollbarCommand.pack(side=&#34;right&#34;, fill=tk.BOTH)
        self.canvas.bind(&#39;&lt;Enter&gt;&#39;, self.boundToMousewheel)
        self.canvas.bind(&#39;&lt;Leave&gt;&#39;, self.unboundToMousewheel)
        self.canvas.pack(side=&#34;left&#34;)
        self.canvas.create_window((0, 0), window=self.commandsViewFrame, anchor=&#39;nw&#39;)
        self.commandsViewFrame.bind(&#34;&lt;Configure&gt;&#34;, self.scrollFrameFunc)
        self.canvas.configure(yscrollcommand=self.myscrollbarCommand.set)
        self.commandsTreevw = CommandsTreeview(self, self.commandsFrameTw)
        scbVSel = ttk.Scrollbar(self.commandsFrameTw,
                                orient=tk.VERTICAL,
                                command=self.commandsTreevw.yview)
        self.commandsTreevw.configure(yscrollcommand=scbVSel.set)
        self.commandsTreevw.grid(row=0, column=0, sticky=tk.NSEW)
        scbVSel.grid(row=0, column=1, sticky=tk.NS)
        self.commandPaned.add(self.commandsFrameTw)
        self.commandPaned.add(self.canvas)
        self.commandPaned.pack(fill=tk.BOTH, expand=1)
        self.commandsFrameTw.rowconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.commandsFrameTw.columnconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
        self.nbk.bind(&#34;&lt;&lt;NotebookTabChanged&gt;&gt;&#34;, self.tabSwitch)
        self.nbk.add(self.commandsPageFrame, text=&#34;Commands&#34;, image=self.commands_tab_img, compound=tk.TOP)

    def showSearchHelp(self, _event=None):
        &#34;&#34;&#34;Called when the searchbar help button is clicked. Display a floating help window with examples
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.helpFrame is None:
            x, y = self.btnHelp.winfo_rootx(), self.btnHelp.winfo_rooty()
            self.helpFrame = FloatingHelpWindow(410, 400, x-380, y+40, self)
        else:
            self.helpFrame.destroy()
            self.helpFrame = None

    def tabSwitch(self, event):
        &#34;&#34;&#34;Called when the user click on the tab menu to switch tab. Add a behaviour before the tab switches.
        Args:
            event : hold informations to identify which tab was clicked.
        &#34;&#34;&#34;
        tabName = self.nbk.tab(self.nbk.select(), &#34;text&#34;).strip()
        self.searchBar.quit()
        if tabName == &#34;Commands&#34;:
            self.commandsTreevw.initUI()
        mongoInstance = MongoCalendar.getInstance()
        if not mongoInstance.hasACalendarOpen():
            opened = self.promptCalendarName()
            if opened is None:
                return
        if tabName == &#34;Scan&#34;:
            if mongoInstance.calendarName is not None:
                if mongoInstance.calendarName != &#34;&#34;:
                    if os.name != &#39;nt&#39;: # Disable on windows
                        # if self.scanManager is None:
                        #    self.scanManager = ScanManager(mongoInstance.calendarName, self.settings)
                        self.scanManager.initUI(self.scanViewFrame)
                    else:
                        lbl = ttk.Label(self.scanViewFrame, text=&#34;Disabled on windows because celery does not support it.&#34;)
                        lbl.pack()
        elif tabName == &#34;Summary&#34;:
            if mongoInstance.calendarName is not None:
                self.summary.refreshUI()
        elif tabName == &#34;Dashboard&#34;:
            if mongoInstance.calendarName is not None:
                self.dashboard.refreshUI()
        elif tabName == &#34;Settings&#34;:
            self.settings.reloadUI()
        elif tabName == &#34;Report&#34;:
            self.report.refreshUI()
        elif tabName == &#34;Terminal&#34;:
            mainDir = os.path.normpath(Utils.getMainDir())
            with open(os.path.join(mainDir, &#34;setupTerminalForPentest.sh&#34;), &#34;r&#34;) as f:
                data = f.read()
                lines = data.split(&#34;\n&#34;)
                lines[0] = &#34;POLLENISATOR_CURRENT_DB=&#34;+str(mongoInstance.calendarName)
                data = &#34;\n&#34;.join(lines)
                with open(os.path.join(mainDir, &#34;setupTerminalForPentest.sh&#34;), &#34;w&#34;) as f:
                    f.write(data)
            favorite = self.settings.getFavoriteTerm()
            if favorite is None:
                tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;None of the terminals given in the settings are installed on this computer.&#34;)
                self.nbk.select(0)
                return
            if which(favorite) is not None:
                terms = self.settings.getTerms()
                terms_dict = {}
                for term in terms:
                    terms_dict[term.split(&#34; &#34;)[0]] = term
                command_term = terms_dict.get(favorite, None)
                if command_term is not None:
                    Utils.execute(terms_dict[favorite])
                else:
                    tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;Check your terminal settings&#34;)
            else:
                tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;The selected favorite terminal is not available on this computer.&#34;)
            self.nbk.select(0)
        elif tabName == &#34;Dashboard&#34;:
            self.dashboard.refreshUI()
        event.widget.winfo_children()[event.widget.index(&#34;current&#34;)].update()

    def initSettingsView(self):
        &#34;&#34;&#34;Add the settings view frame to the notebook widget and initialize its UI.&#34;&#34;&#34;
        self.settingViewFrame = ttk.Frame(self.nbk)
        self.settings.initUI(self.settingViewFrame)
        self.settingViewFrame.pack(fill=tk.BOTH, expand=1)
        self.nbk.add(self.settingViewFrame, text=&#34;  Settings  &#34;, image=self.settings_tab_img, compound=tk.TOP)

    def initScanView(self):
        &#34;&#34;&#34;Add the scan view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.scanViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.scanViewFrame, text=&#34;    Scan     &#34;, image=self.scan_tab_img, compound=tk.TOP)

    def initReportView(self):
        &#34;&#34;&#34;Add the report view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.reportViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.reportViewFrame, text=&#34;   Report   &#34;, image=self.report_tab_img, compound=tk.TOP)

    def initSummaryView(self):
        &#34;&#34;&#34;Add the summary view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.summaryViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.summaryViewFrame, text=&#34; Summary &#34;, image=self.summary_tab_img, compound=tk.TOP)

    def initDashBoardView(self):
        &#34;&#34;&#34;Add the dashboard view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
        self.dashboardViewFrame = ttk.Frame(self.nbk)
        self.nbk.add(self.dashboardViewFrame, text = &#34;Dashboard&#34;,image=self.dashboard_tab_img,compound=tk.TOP)

    def initUI(self):
        &#34;&#34;&#34;
        initialize all the main windows objects. (Bar Menu, contextual menu, treeview, editing pane)
        &#34;&#34;&#34;
        self.nbk = ttk.Notebook(self.parent)
        self.statusbar = StatusBar(self.parent, Settings.getTags(), self)
        self.statusbar.pack(fill=tk.X)
        self.nbk.enable_traversal()
        self.initMainView()
        self.initDashBoardView()
        self.initSummaryView()
        self.initCommandsView()
        self.initScanView()
        self.initReportView()
        self.initSettingsView()
        self._initMenuBar()
        terminal_frame = ttk.Frame(self.nbk)
        self.nbk.add(terminal_frame, text=&#34;  Terminal  &#34;, image=self.terminal_tab_img, compound=tk.TOP)
        self.nbk.pack(fill=tk.BOTH, expand=1)

    def newSearch(self, _event=None):
        &#34;&#34;&#34;Called when the searchbar is validated (click on search button or enter key pressed).
        Perform a filter on the main treeview.
        Args:
            _event: not used but mandatory&#34;&#34;&#34;
        filterStr = self.searchBar.get()
        self.settings.reloadSettings()
        success = self.treevw.filterTreeview(filterStr, self.settings)
        self.searchMode = (success and filterStr.strip() != &#34;&#34;)
        if success:
            histo_filters = self.settings.local_settings.get(&#34;histo_filters&#34;, [])
            if filterStr.strip() != &#34;&#34;:
                histo_filters.insert(0, filterStr)
                if len(histo_filters) &gt; 10:
                    histo_filters = histo_filters[:10]
                self.settings.local_settings[&#34;histo_filters&#34;] = histo_filters
                self.settings.saveLocalSettings()
            if self.helpFrame is not None:
                self.helpFrame.destroy()
                self.helpFrame = None

    def statusbarClicked(self, name):
        &#34;&#34;&#34;Called when a button in the statusbar tag is clicked.
        filter the treeview to match the status bar tag clicked and enforce select of main view
        Args:
            name: not used but mandatory&#34;&#34;&#34;
        # get the index of the mouse click
        self.nbk.select(0)
        self.searchMode = True
        self.treevw.filterTreeview(&#34;\&#34;&#34;+name+&#34;\&#34; in tags&#34;)

    def resetButtonClicked(self):
        &#34;&#34;&#34;
        Called when the reset button of the status bar is clicked.
        &#34;&#34;&#34;
        self.searchMode = False
        self.searchBar.reset()
        self.treevw.unfilter()

    def refreshView(self, _event=None):
        &#34;&#34;&#34;
        Reload the currently opened tab
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        setViewOn = None
        nbkOpenedTab = self.nbk.tab(self.nbk.select(), &#34;text&#34;).strip()
        activeTw = None
        if nbkOpenedTab == &#34;Main View&#34;:
            activeTw = self.treevw
        elif nbkOpenedTab == &#34;Commands&#34;:
            activeTw = self.commandsTreevw
        elif nbkOpenedTab == &#34;Scan&#34;:
            self.scanManager.initUI(self.scanViewFrame)
        elif nbkOpenedTab == &#34;Summary&#34;:
            self.summary.refreshUI()
        elif nbkOpenedTab == &#34;Settings&#34;:
            self.settings.reloadUI()
        elif nbkOpenedTab == &#34;Report&#34;:
            self.report.refreshUI()
        elif nbkOpenedTab == &#34;Dashboard&#34;:
            self.dashboard.refreshUI()
        if activeTw is not None:
            if len(activeTw.selection()) == 1:
                setViewOn = activeTw.selection()[0]
            activeTw.refresh()
        if setViewOn is not None:
            try:
                activeTw.see(setViewOn)
                activeTw.focus(setViewOn)
                activeTw.selection_set(setViewOn)
                activeTw.openModifyWindowOf(setViewOn)
            except tk.TclError:
                pass

    def resetUnfinishedTools(self):
        &#34;&#34;&#34;
        Reset all running tools to a ready state.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        if mongoInstance.hasACalendarOpen():
            Utils.resetUnfinishedTools()
            self.treevw.load()

    def exportCalendar(self):
        &#34;&#34;&#34;
        Dump a pentest database to an archive file gunzip.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        dialog = ChildDialogCombo(self, mongoInstance.listCalendars()[::-1], &#34;Choose a database to dump:&#34;)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, str):
            mongoInstance.dumpDb(dialog.rvalue)

    def exportCommands(self):
        &#34;&#34;&#34;
        Dump pollenisator from database to an archive file gunzip.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.dumpDb(&#34;pollenisator&#34;, &#34;commands&#34;)
        mongoInstance.dumpDb(&#34;pollenisator&#34;, &#34;group_commands&#34;)
        tkinter.messagebox.showinfo(
            &#34;Export pollenisator database&#34;, &#34;Export completed in exports/pollenisator_commands.gzip and exports/pollenisator_group_commands.gzip&#34;)

    def importCalendar(self, name=None):
        &#34;&#34;&#34;
        Import a calendar archive file gunzip to database.
        Args:
            name: The filename of the gunzip database exported previously
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        filename = &#34;&#34;
        if name is None:
            f = tkinter.filedialog.askopenfilename(defaultextension=&#34;.gzip&#34;)
            if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
                return
            filename = str(f)
        else:
            filename = name
        mongoInstance.importDatabase(filename)

    def importCommands(self, name=None):
        &#34;&#34;&#34;
        Import a pollenisator archive file gunzip to database.
        Args:
            name: The filename of the gunzip command table exported previously
        Returns:
            None if name is None and filedialog is closed
            True if commands successfully are imported
            False otherwise.
        &#34;&#34;&#34;
        filename = &#34;&#34;
        if name is None:
            f = tkinter.filedialog.askopenfilename(defaultextension=&#34;.gzip&#34;)
            if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
                return
            filename = str(f)
        else:
            filename = name
        try:
            mongoInstance = MongoCalendar.getInstance()
            mongoInstance.importCommands(filename)
            self.commandsTreevw.refresh()
        except IOError:
            tkinter.messagebox.showerror(
                &#34;Import commands&#34;, &#34;Import failed. &#34;+str(filename)+&#34; was not found or is not a file.&#34;)
            return False
        tkinter.messagebox.showinfo(
            &#34;Import commands&#34;, &#34;Import of &#34;+filename+&#34; completed&#34;)
        return True

    def onExit(self):
        &#34;&#34;&#34;
        Exit the application
        &#34;&#34;&#34;
        self.onClosing()

    def promptCalendarName(self, _event=None):
        &#34;&#34;&#34;
        Ask a user to select an pentest database including a New database option.
        Args:
            _event: Not used but mandatory
        Returns:
            None if no database were selected
            datababase name otherwise
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        calendars = mongoInstance.listCalendars()
        if calendars is None:
            calendars = []
        dialog = ChildDialogCombo(self, [&#34;New database&#34;]+calendars[::-1], &#34;Please select a database&#34;)
        self.wait_window(dialog.app)
        if dialog.rvalue is None:
            return None
        if isinstance(dialog.rvalue, str):
            if dialog.rvalue == &#34;New database&#34;:
                self.selectNewCalendar()
            else:
                self.openCalendar(dialog.rvalue)
            return dialog.rvalue

    def deleteACalendar(self):
        &#34;&#34;&#34;
        Ask a user a calendar name then delete it.
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        dialog = ChildDialogCombo(
            self, mongoInstance.listCalendars()[::-1], &#34;Choose a database to delete:&#34;)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, str):
            calendarName = dialog.rvalue
            ret = tkinter.messagebox.askokcancel(
                &#34;Delete tools on server&#34;, &#34;Do you also want to delete resulting tool files on server sftp ?&#34;)
            if ret:
                self.removeFiles(calendarName)

            ret = tkinter.messagebox.askokcancel(
                &#34;The document will be deleted&#34;, &#34;You are going to delete permanently the database \&#34;&#34;+calendarName+&#34;\&#34;. Are you sure ?&#34;)
            if ret:
                mongoInstance.doDeleteCalendar(calendarName)

            self.treevw.deleteState(calendarName)

    def newCalendar(self, calendarName):
        &#34;&#34;&#34;
        Register the given calendar name into database and opens it.

        Args:
            calendarName: The pentest database name to register in database.
        &#34;&#34;&#34;
        succeed = False
        if calendarName is not None:
            mongoInstance = MongoCalendar.getInstance()
            succeed = mongoInstance.registerCalendar(calendarName, True, True)
        return succeed

    def selectNewCalendar(self):
        &#34;&#34;&#34;
        Ask a user for a new calendar name. Then creates it.
        &#34;&#34;&#34;
        validCalendar = False
        default = {}
        while not validCalendar:
            dialog = ChildDialogNewCalendar(self.parent, default)
            self.wait_window(dialog.app)
            if isinstance(dialog.rvalue, dict):
                default = dialog.rvalue
                dbName = dialog.rvalue[&#34;name&#34;]
                pentest_type = dialog.rvalue[&#34;type&#34;]
                start_date = dialog.rvalue[&#34;start&#34;]
                end_date = dialog.rvalue[&#34;end&#34;]
                scope = dialog.rvalue[&#34;scope&#34;]
                settings = dialog.rvalue[&#34;settings&#34;]
                pentesters = dialog.rvalue[&#34;pentesters&#34;]
                validCalendar = self.newCalendar(dbName)
                if validCalendar:
                    self.openCalendar(dbName)
                    dialog = ChildDialogInfo(
                         self.parent, &#34;New database created&#34;, &#34;Database setup ...&#34;)
                    dialog.show()
                    self.prepareCalendar(dbName, pentest_type, start_date, end_date, scope, settings, pentesters)
                    dialog.destroy()


            else:
                return
            

    def prepareCalendar(self, dbName, pentest_type, start_date, end_date, scope, settings, pentesters):
        &#34;&#34;&#34;
        Initiate a pentest database with wizard info
        Args:
            dbName: the database name
            pentest_type: a pentest type choosen from settings pentest_types. Used to select commands that will be launched by default
            start_date: a begining date and time for the pentest
            end_date: ending date and time for the pentest
            scope: a list of scope valid string (IP, network IP or host name)
            settings: a dict of settings with keys:
                * &#34;Add domains whose IP are in scope&#34;: if 1, will do a dns lookup on new domains and check if found IP is in scope
                * &#34;Add domains who have a parent domain in scope&#34;: if 1, will add a new domain if a parent domain is in scope
                * &#34;Add all domains found&#34;:  Unsafe. if 1, all new domains found by tools will be considered in scope.
        &#34;&#34;&#34;
        commands = Command.getList({&#34;$or&#34;:[{&#34;types&#34;:{&#34;$elemMatch&#34;:{&#34;$eq&#34;:pentest_type}}}, {&#34;types&#34;:{&#34;$elemMatch&#34;:{&#34;$eq&#34;:&#34;Commun&#34;}}}]})
        if not commands:
            commandslist = Command.getList()
            if not commandslist:
                dialog = ChildDialogQuestion(self.parent, &#34;No command found&#34;, &#34;There is no registered command in the database. Would you like to import the default set?&#34;)
                self.parent.wait_window(dialog.app)
                if dialog.rvalue != &#34;Yes&#34;:
                    return
                default = os.path.join(Utils.getMainDir(), &#34;exports/pollenisator_commands.gzip&#34;)
                res = self.importCommands(default)
                if res:
                    default = os.path.join(Utils.getMainDir(), &#34;exports/pollenisator_group_commands.gzip&#34;)
                    res = self.importCommands(default)
        Wave().initialize(dbName, commands).addInDb()
        Interval().initialize(dbName, start_date, end_date).addInDb()
        values = {&#34;wave&#34;:dbName, &#34;Scopes&#34;:scope, &#34;Settings&#34;:False}
        ScopeController(Scope()).doInsert(values)
        self.settings.reloadSettings()
        self.settings.db_settings[&#34;pentest_type&#34;] = pentest_type
        self.settings.db_settings[&#34;include_domains_with_ip_in_scope&#34;] = settings[&#39;Add domains whose IP are in scope&#39;] == 1
        self.settings.db_settings[&#34;include_domains_with_topdomain_in_scope&#34;] = settings[&#34;Add domains who have a parent domain in scope&#34;] == 1
        self.settings.db_settings[&#34;include_all_domains&#34;] = settings[&#34;Add all domains found&#34;] == 1
        self.settings.db_settings[&#34;pentesters&#34;] = list(map(lambda x: x.strip(), pentesters.split(&#34;\n&#34;)))
        self.settings.save()

    def openCalendar(self, filename=&#34;&#34;):
        &#34;&#34;&#34;
        Open the given database name. Loads it in treeview.

        Args:
            filename: the pentest database name to load in application. If &#34;&#34; is given (default), will refresh the already opened database if there is one.
        &#34;&#34;&#34;
        print(&#34;Start monitoring&#34;)
        calendarName = None
        mongoInstance = MongoCalendar.getInstance()
        if filename == &#34;&#34; and mongoInstance.hasACalendarOpen():
            calendarName = mongoInstance.calendarName
        elif filename != &#34;&#34;:
            calendarName = filename.split(&#34;.&#34;)[0].split(&#34;/&#34;)[-1]
        if calendarName is not None:
            if self.scanManager is not None:
                self.scanManager.stop()
            if self.notifications_timers is not None:
                self.notifications_timers.cancel()
                self.notifications_timers = None
            mongoInstance.connectToDb(calendarName)
            for widget in self.viewframe.winfo_children():
                widget.destroy()
            self.report.initUI(self.reportViewFrame)
            self.summary.initUI(self.summaryViewFrame, self.nbk, self.treevw)
            self.dashboard.initUI(self.dashboardViewFrame)
            self.statusbar.reset()
            self.treevw.refresh()
            if os.name != &#34;nt&#34;: # On windows celery 4.X is not managed
                self.scanManager = ScanManager(self.nbk, self.treevw, mongoInstance.calendarName, self.settings)
                self.notifications_timers = threading.Timer(
                    0.5, self.readNotifications)
                self.notifications_timers.start()

    def wrapCopyDb(self, _event=None):
        &#34;&#34;&#34;
        Call default copy database from a callback event.

        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.copyDb()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Pollenisator.core.Application.Appli.Appli.fixedMap"><code class="name flex">
<span>def <span class="ident">fixedMap</span></span>(<span>option, style)</span>
</code></dt>
<dd>
<div class="desc"><p>Fix color tag in treeview not appearing under some linux distros</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>option</code></strong></dt>
<dd>the string option you want to affect on treeview ("background" for example)</dd>
<dt><strong><code>strle</code></strong></dt>
<dd>the style object of ttk</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fixedMap(option, style):
    &#34;&#34;&#34;
    Fix color tag in treeview not appearing under some linux distros
    Args:
        option: the string option you want to affect on treeview (&#34;background&#34; for example)
        strle: the style object of ttk
    &#34;&#34;&#34;
    # Fix for setting text colour for Tkinter 8.6.9
    # From: https://core.tcl.tk/tk/info/509cafafae
    #  FIX tkinter tag_configure not showing colors   https://bugs.python.org/issue36468
    # Returns the style map for &#39;option&#39; with any styles starting with
    # (&#39;!disabled&#39;, &#39;!selected&#39;, ...) filtered out.

    # style.map() returns an empty list for missing options, so this
    # should be future-safe.
    return [elm for elm in style.map(&#39;Treeview&#39;, query_opt=option) if
            elm[:2] != (&#39;!disabled&#39;, &#39;!selected&#39;)]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Pollenisator.core.Application.Appli.Appli.boundToMousewheel"><code class="name flex">
<span>def <span class="ident">boundToMousewheel</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the <strong>command canvas</strong> is on focus.
Bind the command scrollbar button on linux to the command canvas</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundToMousewheel(self, _event):
    &#34;&#34;&#34;Called when the **command canvas** is on focus.
    Bind the command scrollbar button on linux to the command canvas
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    self.canvas.bind_all(&#34;&lt;Button-4&gt;&#34;, self._onMousewheelCommand)
    self.canvas.bind_all(&#34;&lt;Button-5&gt;&#34;, self._onMousewheelCommand)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.boundToMousewheelMain"><code class="name flex">
<span>def <span class="ident">boundToMousewheelMain</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the <strong>main view canvas</strong> is focused.
Bind the main view scrollbar button on linux to the main view canvas</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundToMousewheelMain(self, _event):
    &#34;&#34;&#34;Called when the **main view canvas** is focused.
    Bind the main view scrollbar button on linux to the main view canvas
    Args:
        _event: not used but mandatory&#34;&#34;&#34;
    self.canvas.bind_all(&#34;&lt;Button-4&gt;&#34;, self._onMousewheelMain)
    self.canvas.bind_all(&#34;&lt;Button-5&gt;&#34;, self._onMousewheelMain)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.deleteACalendar"><code class="name flex">
<span>def <span class="ident">deleteACalendar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask a user a calendar name then delete it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteACalendar(self):
    &#34;&#34;&#34;
    Ask a user a calendar name then delete it.
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    dialog = ChildDialogCombo(
        self, mongoInstance.listCalendars()[::-1], &#34;Choose a database to delete:&#34;)
    self.wait_window(dialog.app)
    if isinstance(dialog.rvalue, str):
        calendarName = dialog.rvalue
        ret = tkinter.messagebox.askokcancel(
            &#34;Delete tools on server&#34;, &#34;Do you also want to delete resulting tool files on server sftp ?&#34;)
        if ret:
            self.removeFiles(calendarName)

        ret = tkinter.messagebox.askokcancel(
            &#34;The document will be deleted&#34;, &#34;You are going to delete permanently the database \&#34;&#34;+calendarName+&#34;\&#34;. Are you sure ?&#34;)
        if ret:
            mongoInstance.doDeleteCalendar(calendarName)

        self.treevw.deleteState(calendarName)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.exportCalendar"><code class="name flex">
<span>def <span class="ident">exportCalendar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Dump a pentest database to an archive file gunzip.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportCalendar(self):
    &#34;&#34;&#34;
    Dump a pentest database to an archive file gunzip.
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    dialog = ChildDialogCombo(self, mongoInstance.listCalendars()[::-1], &#34;Choose a database to dump:&#34;)
    self.wait_window(dialog.app)
    if isinstance(dialog.rvalue, str):
        mongoInstance.dumpDb(dialog.rvalue)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.exportCommands"><code class="name flex">
<span>def <span class="ident">exportCommands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Dump pollenisator from database to an archive file gunzip.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportCommands(self):
    &#34;&#34;&#34;
    Dump pollenisator from database to an archive file gunzip.
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    mongoInstance.dumpDb(&#34;pollenisator&#34;, &#34;commands&#34;)
    mongoInstance.dumpDb(&#34;pollenisator&#34;, &#34;group_commands&#34;)
    tkinter.messagebox.showinfo(
        &#34;Export pollenisator database&#34;, &#34;Export completed in exports/pollenisator_commands.gzip and exports/pollenisator_group_commands.gzip&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.getCentralizedFiles"><code class="name flex">
<span>def <span class="ident">getCentralizedFiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Download from SFTP server all files of current database in local directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCentralizedFiles(self):
    &#34;&#34;&#34;Download from SFTP server all files of current database in local directory
    &#34;&#34;&#34;
    fs = FileStorage()
    fs.open()
    fs.getResults()
    fs.close()
    tkinter.messagebox.showinfo(
        &#34;Centralization completed&#34;, &#34;Files were download in results/&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.importCalendar"><code class="name flex">
<span>def <span class="ident">importCalendar</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Import a calendar archive file gunzip to database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The filename of the gunzip database exported previously</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importCalendar(self, name=None):
    &#34;&#34;&#34;
    Import a calendar archive file gunzip to database.
    Args:
        name: The filename of the gunzip database exported previously
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    filename = &#34;&#34;
    if name is None:
        f = tkinter.filedialog.askopenfilename(defaultextension=&#34;.gzip&#34;)
        if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
            return
        filename = str(f)
    else:
        filename = name
    mongoInstance.importDatabase(filename)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.importCommands"><code class="name flex">
<span>def <span class="ident">importCommands</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Import a pollenisator archive file gunzip to database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The filename of the gunzip command table exported previously</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if name is None and filedialog is closed</code></dt>
<dd>&nbsp;</dd>
<dt><code>True if commands successfully are imported</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importCommands(self, name=None):
    &#34;&#34;&#34;
    Import a pollenisator archive file gunzip to database.
    Args:
        name: The filename of the gunzip command table exported previously
    Returns:
        None if name is None and filedialog is closed
        True if commands successfully are imported
        False otherwise.
    &#34;&#34;&#34;
    filename = &#34;&#34;
    if name is None:
        f = tkinter.filedialog.askopenfilename(defaultextension=&#34;.gzip&#34;)
        if f is None:  # asksaveasfile return `None` if dialog closed with &#34;cancel&#34;.
            return
        filename = str(f)
    else:
        filename = name
    try:
        mongoInstance = MongoCalendar.getInstance()
        mongoInstance.importCommands(filename)
        self.commandsTreevw.refresh()
    except IOError:
        tkinter.messagebox.showerror(
            &#34;Import commands&#34;, &#34;Import failed. &#34;+str(filename)+&#34; was not found or is not a file.&#34;)
        return False
    tkinter.messagebox.showinfo(
        &#34;Import commands&#34;, &#34;Import of &#34;+filename+&#34; completed&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initCommandsView"><code class="name flex">
<span>def <span class="ident">initCommandsView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Populate the command tab menu view frame with cool widgets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initCommandsView(self):
    &#34;&#34;&#34;Populate the command tab menu view frame with cool widgets&#34;&#34;&#34;
    self.commandsPageFrame = ttk.Frame(self.nbk)
    self.commandPaned = tk.PanedWindow(self.commandsPageFrame, height=800)
    self.commandsFrameTw = ttk.Frame(self.commandPaned)
    self.canvas = tk.Canvas(self.commandPaned, bg=&#34;white&#34;)
    self.commandsViewFrame = ttk.Frame(self.canvas)
    self.myscrollbarCommand = tk.Scrollbar(self.commandPaned, orient=&#34;vertical&#34;, command=self.canvas.yview)
    self.myscrollbarCommand.pack(side=&#34;right&#34;, fill=tk.BOTH)
    self.canvas.bind(&#39;&lt;Enter&gt;&#39;, self.boundToMousewheel)
    self.canvas.bind(&#39;&lt;Leave&gt;&#39;, self.unboundToMousewheel)
    self.canvas.pack(side=&#34;left&#34;)
    self.canvas.create_window((0, 0), window=self.commandsViewFrame, anchor=&#39;nw&#39;)
    self.commandsViewFrame.bind(&#34;&lt;Configure&gt;&#34;, self.scrollFrameFunc)
    self.canvas.configure(yscrollcommand=self.myscrollbarCommand.set)
    self.commandsTreevw = CommandsTreeview(self, self.commandsFrameTw)
    scbVSel = ttk.Scrollbar(self.commandsFrameTw,
                            orient=tk.VERTICAL,
                            command=self.commandsTreevw.yview)
    self.commandsTreevw.configure(yscrollcommand=scbVSel.set)
    self.commandsTreevw.grid(row=0, column=0, sticky=tk.NSEW)
    scbVSel.grid(row=0, column=1, sticky=tk.NS)
    self.commandPaned.add(self.commandsFrameTw)
    self.commandPaned.add(self.canvas)
    self.commandPaned.pack(fill=tk.BOTH, expand=1)
    self.commandsFrameTw.rowconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
    self.commandsFrameTw.columnconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
    self.nbk.bind(&#34;&lt;&lt;NotebookTabChanged&gt;&gt;&#34;, self.tabSwitch)
    self.nbk.add(self.commandsPageFrame, text=&#34;Commands&#34;, image=self.commands_tab_img, compound=tk.TOP)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initDashBoardView"><code class="name flex">
<span>def <span class="ident">initDashBoardView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the dashboard view frame to the notebook widget. This does not initialize it as it needs a database to be opened.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initDashBoardView(self):
    &#34;&#34;&#34;Add the dashboard view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
    self.dashboardViewFrame = ttk.Frame(self.nbk)
    self.nbk.add(self.dashboardViewFrame, text = &#34;Dashboard&#34;,image=self.dashboard_tab_img,compound=tk.TOP)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initMainView"><code class="name flex">
<span>def <span class="ident">initMainView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill the main view tab menu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initMainView(self):
    &#34;&#34;&#34;
    Fill the main view tab menu
    &#34;&#34;&#34;
    self.mainPageFrame = ttk.Frame(self.nbk)
    searchFrame = ttk.Frame(self.mainPageFrame)
    lblSearch = ttk.Label(searchFrame, text=&#34;Filter bar:&#34;)
    lblSearch.pack(side=&#34;left&#34;, fill=tk.NONE)
    self.searchBar = AutocompleteEntry(self.settings, searchFrame, width=94)
    #self.searchBar = ttk.Entry(searchFrame, width=108)
    self.searchBar.bind(&#39;&lt;Return&gt;&#39;, self.newSearch)
    self.searchBar.bind(&#39;&lt;KP_Enter&gt;&#39;, self.newSearch)
    self.searchBar.bind(&#39;&lt;Control-a&gt;&#39;, self.searchbarSelectAll)
    # searchBar.bind(&#34;&lt;Button-3&gt;&#34;, self.do_popup)
    self.searchBar.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
    btnSearchBar = ttk.Button(searchFrame, text=&#34;Search&#34;, command=self.newSearch)
    btnSearchBar.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
    btnReset = ttk.Button(searchFrame, text=&#34;Reset&#34;,command=self.resetButtonClicked)
    btnReset.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
    self.btnHelp = ttk.Button(searchFrame)
    self.photo = tk.PhotoImage(file=Utils.getHelpIconPath())
    self.helpFrame = None
    self.btnHelp.config(image=self.photo, command=self.showSearchHelp)
    self.btnHelp.pack(side=&#34;left&#34;)
    searchFrame.pack(side=&#34;top&#34;, fill=&#34;x&#34;)
    #PANED PART
    self.paned = tk.PanedWindow(self.mainPageFrame, height=800)
    #RIGHT PANE : Canvas + frame
    self.canvasMain = tk.Canvas(self.paned, bg=&#34;white&#34;)
    self.viewframe = ttk.Frame(self.canvasMain)
    #LEFT PANE : Treeview
    self.frameTw = ttk.Frame(self.paned)
    self.treevw = CalendarTreeview(self, self.frameTw)
    self.treevw.initUI()
    scbVSel = ttk.Scrollbar(self.frameTw,
                            orient=tk.VERTICAL,
                            command=self.treevw.yview)
    self.treevw.configure(yscrollcommand=scbVSel.set)
    self.treevw.grid(row=0, column=0, sticky=tk.NSEW)
    scbVSel.grid(row=0, column=1, sticky=tk.NS)
    self.paned.add(self.frameTw)
    self.myscrollbarMain = tk.Scrollbar(self.paned, orient=&#34;vertical&#34;, command=self.canvasMain.yview)
    self.myscrollbarMain.pack(side=&#34;right&#34;, fill=tk.BOTH)
    self.canvasMain.bind(&#39;&lt;Enter&gt;&#39;, self.boundToMousewheelMain)
    self.canvasMain.bind(&#39;&lt;Leave&gt;&#39;, self.unboundToMousewheelMain)
    self.canvasMain.pack(side=&#34;left&#34;)
    self.canvasMain.create_window((0, 0), window=self.viewframe, anchor=&#39;nw&#39;)
    self.viewframe.bind(&#34;&lt;Configure&gt;&#34;, self.scrollFrameMainFunc)
    self.canvasMain.configure(yscrollcommand=self.myscrollbarMain.set)
    self.paned.add(self.canvasMain)
    self.paned.pack(fill=tk.BOTH, expand=1)
    self.frameTw.rowconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
    self.frameTw.columnconfigure(0, weight=1) # Weight 1 sur un layout grid, sans ça le composant ne changera pas de taille en cas de resize
    self.nbk.add(self.mainPageFrame, text=&#34;Main View &#34;, image=self.main_tab_img, compound=tk.TOP, sticky=&#39;nsew&#39;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initReportView"><code class="name flex">
<span>def <span class="ident">initReportView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the report view frame to the notebook widget. This does not initialize it as it needs a database to be opened.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initReportView(self):
    &#34;&#34;&#34;Add the report view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
    self.reportViewFrame = ttk.Frame(self.nbk)
    self.nbk.add(self.reportViewFrame, text=&#34;   Report   &#34;, image=self.report_tab_img, compound=tk.TOP)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initScanView"><code class="name flex">
<span>def <span class="ident">initScanView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the scan view frame to the notebook widget. This does not initialize it as it needs a database to be opened.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initScanView(self):
    &#34;&#34;&#34;Add the scan view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
    self.scanViewFrame = ttk.Frame(self.nbk)
    self.nbk.add(self.scanViewFrame, text=&#34;    Scan     &#34;, image=self.scan_tab_img, compound=tk.TOP)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initSettingsView"><code class="name flex">
<span>def <span class="ident">initSettingsView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the settings view frame to the notebook widget and initialize its UI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initSettingsView(self):
    &#34;&#34;&#34;Add the settings view frame to the notebook widget and initialize its UI.&#34;&#34;&#34;
    self.settingViewFrame = ttk.Frame(self.nbk)
    self.settings.initUI(self.settingViewFrame)
    self.settingViewFrame.pack(fill=tk.BOTH, expand=1)
    self.nbk.add(self.settingViewFrame, text=&#34;  Settings  &#34;, image=self.settings_tab_img, compound=tk.TOP)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initSummaryView"><code class="name flex">
<span>def <span class="ident">initSummaryView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the summary view frame to the notebook widget. This does not initialize it as it needs a database to be opened.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initSummaryView(self):
    &#34;&#34;&#34;Add the summary view frame to the notebook widget. This does not initialize it as it needs a database to be opened.&#34;&#34;&#34;
    self.summaryViewFrame = ttk.Frame(self.nbk)
    self.nbk.add(self.summaryViewFrame, text=&#34; Summary &#34;, image=self.summary_tab_img, compound=tk.TOP)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>initialize all the main windows objects. (Bar Menu, contextual menu, treeview, editing pane)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    &#34;&#34;&#34;
    initialize all the main windows objects. (Bar Menu, contextual menu, treeview, editing pane)
    &#34;&#34;&#34;
    self.nbk = ttk.Notebook(self.parent)
    self.statusbar = StatusBar(self.parent, Settings.getTags(), self)
    self.statusbar.pack(fill=tk.X)
    self.nbk.enable_traversal()
    self.initMainView()
    self.initDashBoardView()
    self.initSummaryView()
    self.initCommandsView()
    self.initScanView()
    self.initReportView()
    self.initSettingsView()
    self._initMenuBar()
    terminal_frame = ttk.Frame(self.nbk)
    self.nbk.add(terminal_frame, text=&#34;  Terminal  &#34;, image=self.terminal_tab_img, compound=tk.TOP)
    self.nbk.pack(fill=tk.BOTH, expand=1)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.newCalendar"><code class="name flex">
<span>def <span class="ident">newCalendar</span></span>(<span>self, calendarName)</span>
</code></dt>
<dd>
<div class="desc"><p>Register the given calendar name into database and opens it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calendarName</code></strong></dt>
<dd>The pentest database name to register in database.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newCalendar(self, calendarName):
    &#34;&#34;&#34;
    Register the given calendar name into database and opens it.

    Args:
        calendarName: The pentest database name to register in database.
    &#34;&#34;&#34;
    succeed = False
    if calendarName is not None:
        mongoInstance = MongoCalendar.getInstance()
        succeed = mongoInstance.registerCalendar(calendarName, True, True)
    return succeed</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.newSearch"><code class="name flex">
<span>def <span class="ident">newSearch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the searchbar is validated (click on search button or enter key pressed).
Perform a filter on the main treeview.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newSearch(self, _event=None):
    &#34;&#34;&#34;Called when the searchbar is validated (click on search button or enter key pressed).
    Perform a filter on the main treeview.
    Args:
        _event: not used but mandatory&#34;&#34;&#34;
    filterStr = self.searchBar.get()
    self.settings.reloadSettings()
    success = self.treevw.filterTreeview(filterStr, self.settings)
    self.searchMode = (success and filterStr.strip() != &#34;&#34;)
    if success:
        histo_filters = self.settings.local_settings.get(&#34;histo_filters&#34;, [])
        if filterStr.strip() != &#34;&#34;:
            histo_filters.insert(0, filterStr)
            if len(histo_filters) &gt; 10:
                histo_filters = histo_filters[:10]
            self.settings.local_settings[&#34;histo_filters&#34;] = histo_filters
            self.settings.saveLocalSettings()
        if self.helpFrame is not None:
            self.helpFrame.destroy()
            self.helpFrame = None</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.onClosing"><code class="name flex">
<span>def <span class="ident">onClosing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the application properly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onClosing(self):
    &#34;&#34;&#34;
    Close the application properly.
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    mongoInstance.dettach(self)
    if self.scanManager is not None:
        self.scanManager.stop()
    print(&#34;Stopping notifications...&#34;)
    if self.notifications_timers is not None:
        self.notifications_timers.cancel()
    if self.scanManager is not None:
        self.scanManager.monitor.stopWorkersTimer()
    print(&#34;Stopping application...&#34;)
    self.quit()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.onExit"><code class="name flex">
<span>def <span class="ident">onExit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit the application</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onExit(self):
    &#34;&#34;&#34;
    Exit the application
    &#34;&#34;&#34;
    self.onClosing()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.openCalendar"><code class="name flex">
<span>def <span class="ident">openCalendar</span></span>(<span>self, filename='')</span>
</code></dt>
<dd>
<div class="desc"><p>Open the given database name. Loads it in treeview.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the pentest database name to load in application. If "" is given (default), will refresh the already opened database if there is one.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openCalendar(self, filename=&#34;&#34;):
    &#34;&#34;&#34;
    Open the given database name. Loads it in treeview.

    Args:
        filename: the pentest database name to load in application. If &#34;&#34; is given (default), will refresh the already opened database if there is one.
    &#34;&#34;&#34;
    print(&#34;Start monitoring&#34;)
    calendarName = None
    mongoInstance = MongoCalendar.getInstance()
    if filename == &#34;&#34; and mongoInstance.hasACalendarOpen():
        calendarName = mongoInstance.calendarName
    elif filename != &#34;&#34;:
        calendarName = filename.split(&#34;.&#34;)[0].split(&#34;/&#34;)[-1]
    if calendarName is not None:
        if self.scanManager is not None:
            self.scanManager.stop()
        if self.notifications_timers is not None:
            self.notifications_timers.cancel()
            self.notifications_timers = None
        mongoInstance.connectToDb(calendarName)
        for widget in self.viewframe.winfo_children():
            widget.destroy()
        self.report.initUI(self.reportViewFrame)
        self.summary.initUI(self.summaryViewFrame, self.nbk, self.treevw)
        self.dashboard.initUI(self.dashboardViewFrame)
        self.statusbar.reset()
        self.treevw.refresh()
        if os.name != &#34;nt&#34;: # On windows celery 4.X is not managed
            self.scanManager = ScanManager(self.nbk, self.treevw, mongoInstance.calendarName, self.settings)
            self.notifications_timers = threading.Timer(
                0.5, self.readNotifications)
            self.notifications_timers.start()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.prepareCalendar"><code class="name flex">
<span>def <span class="ident">prepareCalendar</span></span>(<span>self, dbName, pentest_type, start_date, end_date, scope, settings, pentesters)</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a pentest database with wizard info</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dbName</code></strong></dt>
<dd>the database name</dd>
<dt><strong><code>pentest_type</code></strong></dt>
<dd>a pentest type choosen from settings pentest_types. Used to select commands that will be launched by default</dd>
<dt><strong><code>start_date</code></strong></dt>
<dd>a begining date and time for the pentest</dd>
<dt><strong><code>end_date</code></strong></dt>
<dd>ending date and time for the pentest</dd>
<dt><strong><code>scope</code></strong></dt>
<dd>a list of scope valid string (IP, network IP or host name)</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>a dict of settings with keys:
* "Add domains whose IP are in scope": if 1, will do a dns lookup on new domains and check if found IP is in scope
* "Add domains who have a parent domain in scope": if 1, will add a new domain if a parent domain is in scope
* "Add all domains found":
Unsafe. if 1, all new domains found by tools will be considered in scope.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareCalendar(self, dbName, pentest_type, start_date, end_date, scope, settings, pentesters):
    &#34;&#34;&#34;
    Initiate a pentest database with wizard info
    Args:
        dbName: the database name
        pentest_type: a pentest type choosen from settings pentest_types. Used to select commands that will be launched by default
        start_date: a begining date and time for the pentest
        end_date: ending date and time for the pentest
        scope: a list of scope valid string (IP, network IP or host name)
        settings: a dict of settings with keys:
            * &#34;Add domains whose IP are in scope&#34;: if 1, will do a dns lookup on new domains and check if found IP is in scope
            * &#34;Add domains who have a parent domain in scope&#34;: if 1, will add a new domain if a parent domain is in scope
            * &#34;Add all domains found&#34;:  Unsafe. if 1, all new domains found by tools will be considered in scope.
    &#34;&#34;&#34;
    commands = Command.getList({&#34;$or&#34;:[{&#34;types&#34;:{&#34;$elemMatch&#34;:{&#34;$eq&#34;:pentest_type}}}, {&#34;types&#34;:{&#34;$elemMatch&#34;:{&#34;$eq&#34;:&#34;Commun&#34;}}}]})
    if not commands:
        commandslist = Command.getList()
        if not commandslist:
            dialog = ChildDialogQuestion(self.parent, &#34;No command found&#34;, &#34;There is no registered command in the database. Would you like to import the default set?&#34;)
            self.parent.wait_window(dialog.app)
            if dialog.rvalue != &#34;Yes&#34;:
                return
            default = os.path.join(Utils.getMainDir(), &#34;exports/pollenisator_commands.gzip&#34;)
            res = self.importCommands(default)
            if res:
                default = os.path.join(Utils.getMainDir(), &#34;exports/pollenisator_group_commands.gzip&#34;)
                res = self.importCommands(default)
    Wave().initialize(dbName, commands).addInDb()
    Interval().initialize(dbName, start_date, end_date).addInDb()
    values = {&#34;wave&#34;:dbName, &#34;Scopes&#34;:scope, &#34;Settings&#34;:False}
    ScopeController(Scope()).doInsert(values)
    self.settings.reloadSettings()
    self.settings.db_settings[&#34;pentest_type&#34;] = pentest_type
    self.settings.db_settings[&#34;include_domains_with_ip_in_scope&#34;] = settings[&#39;Add domains whose IP are in scope&#39;] == 1
    self.settings.db_settings[&#34;include_domains_with_topdomain_in_scope&#34;] = settings[&#34;Add domains who have a parent domain in scope&#34;] == 1
    self.settings.db_settings[&#34;include_all_domains&#34;] = settings[&#34;Add all domains found&#34;] == 1
    self.settings.db_settings[&#34;pentesters&#34;] = list(map(lambda x: x.strip(), pentesters.split(&#34;\n&#34;)))
    self.settings.save()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.promptCalendarName"><code class="name flex">
<span>def <span class="ident">promptCalendarName</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask a user to select an pentest database including a New database option.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>Not used but mandatory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if no database were selected</code></dt>
<dd>&nbsp;</dd>
<dt><code>datababase name otherwise</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def promptCalendarName(self, _event=None):
    &#34;&#34;&#34;
    Ask a user to select an pentest database including a New database option.
    Args:
        _event: Not used but mandatory
    Returns:
        None if no database were selected
        datababase name otherwise
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    calendars = mongoInstance.listCalendars()
    if calendars is None:
        calendars = []
    dialog = ChildDialogCombo(self, [&#34;New database&#34;]+calendars[::-1], &#34;Please select a database&#34;)
    self.wait_window(dialog.app)
    if dialog.rvalue is None:
        return None
    if isinstance(dialog.rvalue, str):
        if dialog.rvalue == &#34;New database&#34;:
            self.selectNewCalendar()
        else:
            self.openCalendar(dialog.rvalue)
        return dialog.rvalue</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.promptForConnection"><code class="name flex">
<span>def <span class="ident">promptForConnection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close current database connection and open connection form for the user</p>
<p>Returns:
The number of pollenisator database found, 0 if the connection failed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def promptForConnection(self):
    &#34;&#34;&#34;Close current database connection and open connection form for the user
    
    Returns: 
        The number of pollenisator database found, 0 if the connection failed.&#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    mongoInstance.reinitConnection()
    connectDialog = ChildDialogConnect(self.parent)
    self.wait_window(connectDialog.app)
    return connectDialog.rvalue</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.readNotifications"><code class="name flex">
<span>def <span class="ident">readNotifications</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read notifications from database every 0.5 or so second. Notifications are used to exchange informations between applications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readNotifications(self):
    &#34;&#34;&#34;
    Read notifications from database every 0.5 or so second. Notifications are used to exchange informations between applications.
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    for old_notif in self.old_notifs:
        mongoInstance.deleteFromDb(&#34;pollenisator&#34;, &#34;notifications&#34;, {&#34;_id&#34;: old_notif})
    self.old_notifs = []
    try:
        notifications = mongoInstance.findInDb(&#34;pollenisator&#34;, &#34;notifications&#34;, {&#34;$or&#34;:[{&#34;db&#34;:str(mongoInstance.calendarName)}, {&#34;db&#34;:&#34;pollenisator&#34;}]})
        for notification in notifications:
            # print(&#34;Notification received &#34;+str(notification[&#34;db&#34;])+&#34;/&#34;+str(notification[&#34;collection&#34;])+&#34; iid=&#34;+str(notification[&#34;iid&#34;])+&#34; action=&#34;+str(notification[&#34;action&#34;]))
            self.old_notifs.append(notification[&#34;_id&#34;])
            if notification[&#34;db&#34;] == &#34;pollenisator&#34;:
                if notification[&#34;collection&#34;] == &#34;workers&#34;:
                    self.scanManager.notify(notification[&#34;iid&#34;], notification[&#34;action&#34;])
                elif &#34;commands&#34; in notification[&#34;collection&#34;]:
                    self.commandsTreevw.notify(notification[&#34;db&#34;], notification[&#34;collection&#34;], notification[&#34;iid&#34;], notification[&#34;action&#34;], notification.get(&#34;parent&#34;, &#34;&#34;))
            else:
                self.treevw.notify(notification[&#34;db&#34;], notification[&#34;collection&#34;],
                                notification[&#34;iid&#34;], notification[&#34;action&#34;], notification.get(&#34;parent&#34;, &#34;&#34;))
    except Exception as e:
        print(str(e))
    self.notifications_timers = threading.Timer(
        0.5, self.readNotifications)
    self.notifications_timers.start()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.refreshView"><code class="name flex">
<span>def <span class="ident">refreshView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reload the currently opened tab</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshView(self, _event=None):
    &#34;&#34;&#34;
    Reload the currently opened tab
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    setViewOn = None
    nbkOpenedTab = self.nbk.tab(self.nbk.select(), &#34;text&#34;).strip()
    activeTw = None
    if nbkOpenedTab == &#34;Main View&#34;:
        activeTw = self.treevw
    elif nbkOpenedTab == &#34;Commands&#34;:
        activeTw = self.commandsTreevw
    elif nbkOpenedTab == &#34;Scan&#34;:
        self.scanManager.initUI(self.scanViewFrame)
    elif nbkOpenedTab == &#34;Summary&#34;:
        self.summary.refreshUI()
    elif nbkOpenedTab == &#34;Settings&#34;:
        self.settings.reloadUI()
    elif nbkOpenedTab == &#34;Report&#34;:
        self.report.refreshUI()
    elif nbkOpenedTab == &#34;Dashboard&#34;:
        self.dashboard.refreshUI()
    if activeTw is not None:
        if len(activeTw.selection()) == 1:
            setViewOn = activeTw.selection()[0]
        activeTw.refresh()
    if setViewOn is not None:
        try:
            activeTw.see(setViewOn)
            activeTw.focus(setViewOn)
            activeTw.selection_set(setViewOn)
            activeTw.openModifyWindowOf(setViewOn)
        except tk.TclError:
            pass</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.removeFiles"><code class="name flex">
<span>def <span class="ident">removeFiles</span></span>(<span>self, calendarName)</span>
</code></dt>
<dd>
<div class="desc"><p>Open git issues in browser</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calendarName</code></strong></dt>
<dd>database name to be removed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeFiles(self, calendarName):
    &#34;&#34;&#34;Open git issues in browser
    Args:
        calendarName: database name to be removed.
    &#34;&#34;&#34;
    fs = FileStorage()
    fs.open()
    fs.rmDbResults(calendarName.strip())
    fs.rmDbProofs(calendarName.strip())
    fs.close()
    tkinter.messagebox.showinfo(
        &#34;Deleting tool&#34;, &#34;Files were removed on sftp for &#34;+str(calendarName))</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.resetButtonClicked"><code class="name flex">
<span>def <span class="ident">resetButtonClicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the reset button of the status bar is clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetButtonClicked(self):
    &#34;&#34;&#34;
    Called when the reset button of the status bar is clicked.
    &#34;&#34;&#34;
    self.searchMode = False
    self.searchBar.reset()
    self.treevw.unfilter()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.resetUnfinishedTools"><code class="name flex">
<span>def <span class="ident">resetUnfinishedTools</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all running tools to a ready state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetUnfinishedTools(self):
    &#34;&#34;&#34;
    Reset all running tools to a ready state.
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    if mongoInstance.hasACalendarOpen():
        Utils.resetUnfinishedTools()
        self.treevw.load()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.scrollFrameFunc"><code class="name flex">
<span>def <span class="ident">scrollFrameFunc</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>make the command canvas scrollable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollFrameFunc(self, _event):
    &#34;&#34;&#34;make the command canvas scrollable&#34;&#34;&#34;
    self.canvas.configure(scrollregion=self.canvas.bbox(&#34;all&#34;), width=20, height=200)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.scrollFrameMainFunc"><code class="name flex">
<span>def <span class="ident">scrollFrameMainFunc</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>make the main canvas scrollable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollFrameMainFunc(self, _event):
    &#34;&#34;&#34;make the main canvas scrollable&#34;&#34;&#34;
    self.canvasMain.configure(scrollregion=self.canvasMain.bbox(&#34;all&#34;), width=20, height=200)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.searchbarSelectAll"><code class="name flex">
<span>def <span class="ident">searchbarSelectAll</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to select all the text in searchbar</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def searchbarSelectAll(self, _event):
    &#34;&#34;&#34;
    Callback to select all the text in searchbar
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    self.searchBar.select_range(0, &#39;end&#39;)
    self.searchBar.icursor(&#39;end&#39;)
    return &#34;break&#34;</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.selectNewCalendar"><code class="name flex">
<span>def <span class="ident">selectNewCalendar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask a user for a new calendar name. Then creates it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectNewCalendar(self):
    &#34;&#34;&#34;
    Ask a user for a new calendar name. Then creates it.
    &#34;&#34;&#34;
    validCalendar = False
    default = {}
    while not validCalendar:
        dialog = ChildDialogNewCalendar(self.parent, default)
        self.wait_window(dialog.app)
        if isinstance(dialog.rvalue, dict):
            default = dialog.rvalue
            dbName = dialog.rvalue[&#34;name&#34;]
            pentest_type = dialog.rvalue[&#34;type&#34;]
            start_date = dialog.rvalue[&#34;start&#34;]
            end_date = dialog.rvalue[&#34;end&#34;]
            scope = dialog.rvalue[&#34;scope&#34;]
            settings = dialog.rvalue[&#34;settings&#34;]
            pentesters = dialog.rvalue[&#34;pentesters&#34;]
            validCalendar = self.newCalendar(dbName)
            if validCalendar:
                self.openCalendar(dbName)
                dialog = ChildDialogInfo(
                     self.parent, &#34;New database created&#34;, &#34;Database setup ...&#34;)
                dialog.show()
                self.prepareCalendar(dbName, pentest_type, start_date, end_date, scope, settings, pentesters)
                dialog.destroy()


        else:
            return</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.setStyle"><code class="name flex">
<span>def <span class="ident">setStyle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the pollenisator window widget style using ttk.Style</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStyle(self, _event=None):
    &#34;&#34;&#34;
    Set the pollenisator window widget style using ttk.Style
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    style = ttk.Style(self.parent)
    style.theme_use(&#34;clam&#34;)
    try:
        style.element_create(&#39;Plain.Notebook.tab&#39;, &#34;from&#34;, &#39;default&#39;)
    except TclError:
        pass # ALready exists
    style.configure(&#34;Treeview.Heading&#34;, background=&#34;#73B723&#34;,
                    foreground=&#34;white&#34;, relief=&#34;flat&#34;)
    style.map(&#39;Treeview.Heading&#39;, background=[(&#39;active&#39;, &#39;#73B723&#39;)])
    style.configure(&#34;TLabelframe&#34;, background=&#34;white&#34;,
                    labeloutside=False, bordercolor=&#34;#73B723&#34;)
    style.configure(&#39;TLabelframe.Label&#39;, background=&#34;#73B723&#34;,
                    foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))
    style.configure(&#34;TProgressbar&#34;,
                    background=&#34;#73D723&#34;, foreground=&#34;#73D723&#34;, troughcolor=&#34;white&#34;, darkcolor=&#34;#73D723&#34;, lightcolor=&#34;#73D723&#34;)
    style.configure(&#34;Important.TFrame&#34;, background=&#34;#73B723&#34;)
    style.configure(&#34;TFrame&#34;, background=&#34;white&#34;)
    style.configure(&#34;Important.TLabel&#34;, background=&#34;#73B723&#34;, foreground=&#34;white&#34;)
    style.configure(&#34;TLabel&#34;, background=&#34;white&#34;)
    style.configure(&#34;TCombobox&#34;, background=&#34;white&#34;)
    style.configure(&#34;TCheckbutton&#34;, background=&#34;white&#34;,
                    font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))
    style.configure(&#34;TButton&#34;, background=&#34;#73B723&#34;,
                    foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), borderwidth=1)
    style.configure(&#34;TNotebook&#34;, background=&#34;#73B723&#34;, foreground=&#34;white&#34;, font=(
        &#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), tabposition=&#39;wn&#39;, borderwidth=0, width=100)

    style.configure(&#34;TNotebook.Tab&#34;, background=&#34;#73B723&#34;, borderwidth=0,
                    foreground=&#34;white&#34;, font=(&#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;), padding=20, bordercolor=&#34;#73B723&#34;)
    style.map(&#39;TNotebook.Tab&#39;, background=[(&#39;active&#39;, &#39;#73C723&#39;), (&#34;selected&#34;, &#39;#73D723&#39;)], foreground=[(&#34;active&#34;, &#34;white&#34;)], font=[(&#34;active&#34;, (
        &#39;Sans&#39;, &#39;10&#39;, &#39;bold&#39;))], padding=[(&#39;active&#39;, 20)])
    style.map(&#39;TButton&#39;, background=[(&#39;active&#39;, &#39;#73D723&#39;)])
    #  FIX tkinter tag_configure not showing colors   https://bugs.python.org/issue36468
    style.map(&#39;Treeview&#39;, foreground=Appli.fixedMap(&#39;foreground&#39;, style),
              background=Appli.fixedMap(&#39;background&#39;, style))
    # Removed dashed line https://stackoverflow.com/questions/23354303/removing-ttk-notebook-tab-dashed-line/23399786
    style.layout(&#34;TNotebook.Tab&#34;,
                 [(&#39;Plain.Notebook.tab&#39;,
                   {&#39;children&#39;:[(&#39;Notebook.padding&#39;, {&#39;side&#39;: &#39;top&#39;, &#39;children&#39;: [(&#39;Notebook.label&#39;, {
                       &#39;side&#39;: &#39;top&#39;, &#39;sticky&#39;: &#39;&#39;})], &#39;sticky&#39;: &#39;nswe&#39;})],
                    &#39;sticky&#39;: &#39;nswe&#39;})])</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.showSearchHelp"><code class="name flex">
<span>def <span class="ident">showSearchHelp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the searchbar help button is clicked. Display a floating help window with examples</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showSearchHelp(self, _event=None):
    &#34;&#34;&#34;Called when the searchbar help button is clicked. Display a floating help window with examples
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    if self.helpFrame is None:
        x, y = self.btnHelp.winfo_rootx(), self.btnHelp.winfo_rooty()
        self.helpFrame = FloatingHelpWindow(410, 400, x-380, y+40, self)
    else:
        self.helpFrame.destroy()
        self.helpFrame = None</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.show_error"><code class="name flex">
<span>def <span class="ident">show_error</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for tk.Tk.report_callback_exception.
Open a window to display exception with some actions possible</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>3 args are required for tk.Tk.report_callback_exception event to be given to traceback.format_exception(args[0], args[1], args[2])</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>If an exception occurs in this handler thread, will print it and exit with exit code 1</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_error(self, *args):
    &#34;&#34;&#34;Callback for tk.Tk.report_callback_exception.
    Open a window to display exception with some actions possible

    Args:
        args: 3 args are required for tk.Tk.report_callback_exception event to be given to traceback.format_exception(args[0], args[1], args[2])
    
    Raises:
        If an exception occurs in this handler thread, will print it and exit with exit code 1
    &#34;&#34;&#34;
    try:
        err = traceback.format_exception(args[0], args[1], args[2])
        dialog = ChildDialogException(self, &#39;Exception occured&#39;, err)
        self.wait_window(dialog.app)
    except Exception as e:
        print(e)
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.statusbarClicked"><code class="name flex">
<span>def <span class="ident">statusbarClicked</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a button in the statusbar tag is clicked.
filter the treeview to match the status bar tag clicked and enforce select of main view</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statusbarClicked(self, name):
    &#34;&#34;&#34;Called when a button in the statusbar tag is clicked.
    filter the treeview to match the status bar tag clicked and enforce select of main view
    Args:
        name: not used but mandatory&#34;&#34;&#34;
    # get the index of the mouse click
    self.nbk.select(0)
    self.searchMode = True
    self.treevw.filterTreeview(&#34;\&#34;&#34;+name+&#34;\&#34; in tags&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.submitIssue"><code class="name flex">
<span>def <span class="ident">submitIssue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Open git issues in browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submitIssue(self):
    &#34;&#34;&#34;Open git issues in browser&#34;&#34;&#34;
    import webbrowser
    webbrowser.open_new_tab(&#34;https://github.com/AlgoSecure/Pollenisator/issues&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.tabSwitch"><code class="name flex">
<span>def <span class="ident">tabSwitch</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the user click on the tab menu to switch tab. Add a behaviour before the tab switches.</p>
<h2 id="args">Args</h2>
<p>event : hold informations to identify which tab was clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tabSwitch(self, event):
    &#34;&#34;&#34;Called when the user click on the tab menu to switch tab. Add a behaviour before the tab switches.
    Args:
        event : hold informations to identify which tab was clicked.
    &#34;&#34;&#34;
    tabName = self.nbk.tab(self.nbk.select(), &#34;text&#34;).strip()
    self.searchBar.quit()
    if tabName == &#34;Commands&#34;:
        self.commandsTreevw.initUI()
    mongoInstance = MongoCalendar.getInstance()
    if not mongoInstance.hasACalendarOpen():
        opened = self.promptCalendarName()
        if opened is None:
            return
    if tabName == &#34;Scan&#34;:
        if mongoInstance.calendarName is not None:
            if mongoInstance.calendarName != &#34;&#34;:
                if os.name != &#39;nt&#39;: # Disable on windows
                    # if self.scanManager is None:
                    #    self.scanManager = ScanManager(mongoInstance.calendarName, self.settings)
                    self.scanManager.initUI(self.scanViewFrame)
                else:
                    lbl = ttk.Label(self.scanViewFrame, text=&#34;Disabled on windows because celery does not support it.&#34;)
                    lbl.pack()
    elif tabName == &#34;Summary&#34;:
        if mongoInstance.calendarName is not None:
            self.summary.refreshUI()
    elif tabName == &#34;Dashboard&#34;:
        if mongoInstance.calendarName is not None:
            self.dashboard.refreshUI()
    elif tabName == &#34;Settings&#34;:
        self.settings.reloadUI()
    elif tabName == &#34;Report&#34;:
        self.report.refreshUI()
    elif tabName == &#34;Terminal&#34;:
        mainDir = os.path.normpath(Utils.getMainDir())
        with open(os.path.join(mainDir, &#34;setupTerminalForPentest.sh&#34;), &#34;r&#34;) as f:
            data = f.read()
            lines = data.split(&#34;\n&#34;)
            lines[0] = &#34;POLLENISATOR_CURRENT_DB=&#34;+str(mongoInstance.calendarName)
            data = &#34;\n&#34;.join(lines)
            with open(os.path.join(mainDir, &#34;setupTerminalForPentest.sh&#34;), &#34;w&#34;) as f:
                f.write(data)
        favorite = self.settings.getFavoriteTerm()
        if favorite is None:
            tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;None of the terminals given in the settings are installed on this computer.&#34;)
            self.nbk.select(0)
            return
        if which(favorite) is not None:
            terms = self.settings.getTerms()
            terms_dict = {}
            for term in terms:
                terms_dict[term.split(&#34; &#34;)[0]] = term
            command_term = terms_dict.get(favorite, None)
            if command_term is not None:
                Utils.execute(terms_dict[favorite])
            else:
                tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;Check your terminal settings&#34;)
        else:
            tkinter.messagebox.showerror(&#34;Terminal settings invalid&#34;, &#34;The selected favorite terminal is not available on this computer.&#34;)
        self.nbk.select(0)
    elif tabName == &#34;Dashboard&#34;:
        self.dashboard.refreshUI()
    event.widget.winfo_children()[event.widget.index(&#34;current&#34;)].update()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.unboundToMousewheel"><code class="name flex">
<span>def <span class="ident">unboundToMousewheel</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the <strong>command canvas</strong> is unfocused.
Unbind the command scrollbar button on linux to the command canvas</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unboundToMousewheel(self, _event):
    &#34;&#34;&#34;Called when the **command canvas** is unfocused.
    Unbind the command scrollbar button on linux to the command canvas
    Args:
        _event: not used but mandatory&#34;&#34;&#34;
    self.canvas.unbind_all(&#34;&lt;Button-4&gt;&#34;)
    self.canvas.unbind_all(&#34;&lt;Button-5&gt;&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.unboundToMousewheelMain"><code class="name flex">
<span>def <span class="ident">unboundToMousewheelMain</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the <strong>main view canvas</strong> is unfocused.
Unbind the main view scrollbar button on linux to the main view canvas</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unboundToMousewheelMain(self, _event):
    &#34;&#34;&#34;Called when the **main view canvas** is unfocused.
    Unbind the main view scrollbar button on linux to the main view canvas
    Args:
        _event: not used but mandatory&#34;&#34;&#34;
    self.canvasMain.unbind_all(&#34;&lt;Button-4&gt;&#34;)
    self.canvasMain.unbind_all(&#34;&lt;Button-5&gt;&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.Appli.wrapCopyDb"><code class="name flex">
<span>def <span class="ident">wrapCopyDb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call default copy database from a callback event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapCopyDb(self, _event=None):
    &#34;&#34;&#34;
    Call default copy database from a callback event.

    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    mongoInstance = MongoCalendar.getInstance()
    mongoInstance.copyDb()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry"><code class="flex name class">
<span>class <span class="ident">AutocompleteEntry</span></span>
<span>(</span><span>settings, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Inherit ttk.Entry.
An entry with an autocompletion ability.
Found on the internet : <a href="http://code.activestate.com/recipes/578253-an-entry-with-autocompletion-for-the-tkinter-gui/">http://code.activestate.com/recipes/578253-an-entry-with-autocompletion-for-the-tkinter-gui/</a>
But a bit modified.</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>settings</code></strong></dt>
<dd>a dict of Settings:
* histo_filters: number of history search to display</dd>
<dt><strong><code>args</code></strong></dt>
<dd>not used</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>
<ul>
<li>width: default to 100</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutocompleteEntry(ttk.Entry):
    &#34;&#34;&#34;Inherit ttk.Entry.
    An entry with an autocompletion ability.
    Found on the internet : http://code.activestate.com/recipes/578253-an-entry-with-autocompletion-for-the-tkinter-gui/
    But a bit modified.
    &#34;&#34;&#34;

    def __init__(self, settings, *args, **kwargs):
        &#34;&#34;&#34;Constructor
        Args:
            settings: a dict of Settings:
                * histo_filters: number of history search to display
            args: not used
            kwargs: 
                * width: default to 100
        &#34;&#34;&#34;
        ttk.Entry.__init__(self, *args, **kwargs)
        self.width = kwargs.get(&#34;width&#34;,100)
        self.lista = set()
        self.var = self[&#34;textvariable&#34;]
        if self.var == &#39;&#39;:
            self.var = self[&#34;textvariable&#34;] = tk.StringVar()
        self.var.trace(&#39;w&#39;, self.changed)
        
        self.bind(&#34;&lt;Right&gt;&#34;, self.selection)
        self.bind(&#34;&lt;Up&gt;&#34;, self.upArrow)
        self.bind(&#34;&lt;Down&gt;&#34;, self.downArrow)
        self.settings = settings
        self.lb = None
        self.lb_up = False

    def changed(self, _name=None, _index=None, _mode=None):
        &#34;&#34;&#34;
        Called when the entry is modified. Perform autocompletion.
        Args:
            _name: not used but mandatory for tk.StringVar.trace
            _index: not used but mandatory for tk.StringVar.trace
            _mode: not used but mandatory for tk.StringVar.trace
        &#34;&#34;&#34;
        words = self.comparison()
        if words:
            if not self.lb_up:
                self.lb = tk.Listbox(width=self.width)
                self.lb.bind(&#34;&lt;Double-Button-1&gt;&#34;, self.selection)
                self.lb.bind(&#34;&lt;Right&gt;&#34;, self.selection)
                self.lb.bind(&#34;&lt;Leave&gt;&#34;, self.quit)
                self.bind(&#34;&lt;Escape&gt;&#34;, self.quit)
                self.lb.place(x=self.winfo_x()+133,
                                y=self.winfo_y()+self.winfo_height()+20)
                self.lb_up = True
            self.lb.delete(0, tk.END)
            for w in words:
                self.lb.insert(tk.END, w)
        else:
            self.quit()

    def quit(self, _event=None):
        &#34;&#34;&#34;
        Callback function to destroy the label shown
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            self.lb.destroy()
            self.lb_up = False
    
    def reset(self):
        &#34;&#34;&#34;
        quit and reset filter bar
        &#34;&#34;&#34;
        self.quit()
        self.var.set(&#34;&#34;)

    def selection(self, _event):
        &#34;&#34;&#34;
        Called when an autocompletion option is chosen. 
        Change entry content and close autocomplete.
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            self.var.set(self.lb.get(tk.ACTIVE))
            self.lb.destroy()
            self.lb_up = False
            self.icursor(tk.END)
            #self.changed()

    def upArrow(self, _event):
        &#34;&#34;&#34;
        Called when the up arrow is pressed. Navigate in autocompletion options
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            if self.lb.curselection() == ():
                index = &#39;0&#39;
            else:
                index = self.lb.curselection()[0]
            if index != &#39;0&#39;:
                self.lb.selection_clear(first=index)
                index = str(int(index)-1)
                self.lb.selection_set(first=index)
                self.lb.activate(index)

    def downArrow(self, _event):
        &#34;&#34;&#34;
        Called when the down arrow is pressed. Navigate in autocompletion options
        Args:
            _event: not used but mandatory
        &#34;&#34;&#34;
        if self.lb_up:
            if self.lb.curselection() == ():
                index = &#39;0&#39;
            else:
                index = self.lb.curselection()[0]
            if index != tk.END:
                self.lb.selection_clear(first=index)
                index = str(int(index)+1)
                self.lb.selection_set(first=index)
                self.lb.activate(index)

    def comparison(self):
        &#34;&#34;&#34;
        Search suggestions in regard of what is in the entry
        &#34;&#34;&#34;
        values = set(self.settings.local_settings.get(&#34;histo_filters&#34;, []))
        self.lista = values
        content = self.var.get().strip()
        if content == &#34;&#34;:
            return []
        pattern = re.compile(&#39;.*&#39; + re.escape(content) + &#39;.*&#39;)
        return [w for w in self.lista if re.match(pattern, w)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Entry</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Entry</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li>tkinter.XView</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.changed"><code class="name flex">
<span>def <span class="ident">changed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the entry is modified. Perform autocompletion.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_name</code></strong></dt>
<dd>not used but mandatory for tk.StringVar.trace</dd>
<dt><strong><code>_index</code></strong></dt>
<dd>not used but mandatory for tk.StringVar.trace</dd>
<dt><strong><code>_mode</code></strong></dt>
<dd>not used but mandatory for tk.StringVar.trace</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changed(self, _name=None, _index=None, _mode=None):
    &#34;&#34;&#34;
    Called when the entry is modified. Perform autocompletion.
    Args:
        _name: not used but mandatory for tk.StringVar.trace
        _index: not used but mandatory for tk.StringVar.trace
        _mode: not used but mandatory for tk.StringVar.trace
    &#34;&#34;&#34;
    words = self.comparison()
    if words:
        if not self.lb_up:
            self.lb = tk.Listbox(width=self.width)
            self.lb.bind(&#34;&lt;Double-Button-1&gt;&#34;, self.selection)
            self.lb.bind(&#34;&lt;Right&gt;&#34;, self.selection)
            self.lb.bind(&#34;&lt;Leave&gt;&#34;, self.quit)
            self.bind(&#34;&lt;Escape&gt;&#34;, self.quit)
            self.lb.place(x=self.winfo_x()+133,
                            y=self.winfo_y()+self.winfo_height()+20)
            self.lb_up = True
        self.lb.delete(0, tk.END)
        for w in words:
            self.lb.insert(tk.END, w)
    else:
        self.quit()</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.comparison"><code class="name flex">
<span>def <span class="ident">comparison</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Search suggestions in regard of what is in the entry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison(self):
    &#34;&#34;&#34;
    Search suggestions in regard of what is in the entry
    &#34;&#34;&#34;
    values = set(self.settings.local_settings.get(&#34;histo_filters&#34;, []))
    self.lista = values
    content = self.var.get().strip()
    if content == &#34;&#34;:
        return []
    pattern = re.compile(&#39;.*&#39; + re.escape(content) + &#39;.*&#39;)
    return [w for w in self.lista if re.match(pattern, w)]</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.downArrow"><code class="name flex">
<span>def <span class="ident">downArrow</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the down arrow is pressed. Navigate in autocompletion options</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downArrow(self, _event):
    &#34;&#34;&#34;
    Called when the down arrow is pressed. Navigate in autocompletion options
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    if self.lb_up:
        if self.lb.curselection() == ():
            index = &#39;0&#39;
        else:
            index = self.lb.curselection()[0]
        if index != tk.END:
            self.lb.selection_clear(first=index)
            index = str(int(index)+1)
            self.lb.selection_set(first=index)
            self.lb.activate(index)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function to destroy the label shown</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self, _event=None):
    &#34;&#34;&#34;
    Callback function to destroy the label shown
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    if self.lb_up:
        self.lb.destroy()
        self.lb_up = False</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>quit and reset filter bar</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    quit and reset filter bar
    &#34;&#34;&#34;
    self.quit()
    self.var.set(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.selection"><code class="name flex">
<span>def <span class="ident">selection</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when an autocompletion option is chosen.
Change entry content and close autocomplete.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selection(self, _event):
    &#34;&#34;&#34;
    Called when an autocompletion option is chosen. 
    Change entry content and close autocomplete.
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    if self.lb_up:
        self.var.set(self.lb.get(tk.ACTIVE))
        self.lb.destroy()
        self.lb_up = False
        self.icursor(tk.END)</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.AutocompleteEntry.upArrow"><code class="name flex">
<span>def <span class="ident">upArrow</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the up arrow is pressed. Navigate in autocompletion options</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upArrow(self, _event):
    &#34;&#34;&#34;
    Called when the up arrow is pressed. Navigate in autocompletion options
    Args:
        _event: not used but mandatory
    &#34;&#34;&#34;
    if self.lb_up:
        if self.lb.curselection() == ():
            index = &#39;0&#39;
        else:
            index = self.lb.curselection()[0]
        if index != &#39;0&#39;:
            self.lb.selection_clear(first=index)
            index = str(int(index)-1)
            self.lb.selection_set(first=index)
            self.lb.activate(index)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Pollenisator.core.Application.Appli.FloatingHelpWindow"><code class="flex name class">
<span>class <span class="ident">FloatingHelpWindow</span></span>
<span>(</span><span>w, h, posx, posy, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>floating basic window with helping text inside
Inherit tkinter TopLevel
Found on the internet (stackoverflow) but did not keep link sorry&hellip;</p>
<p>Construct a toplevel widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, menu, relief, screen, takefocus,
use, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FloatingHelpWindow(tk.Toplevel):
    &#34;&#34;&#34;floating basic window with helping text inside
    Inherit tkinter TopLevel
    Found on the internet (stackoverflow) but did not keep link sorry...
    &#34;&#34;&#34;

    def __init__(self, w, h, posx, posy, *args, **kwargs):
        tk.Toplevel.__init__(self, *args, **kwargs)
        self.title(&#39;Help: search&#39;)
        self.x = posx
        self.y = posy
        self.geometry(str(w)+&#34;x&#34;+str(h)+&#34;+&#34;+str(posx)+&#34;+&#34;+str(posy))
        self.resizable(0, 0)
        self.config(bg=&#39;light yellow&#39;)
        self.grip = tk.Label(self, bitmap=&#34;gray25&#34;)
        self.grip.pack(side=&#34;left&#34;, fill=&#34;y&#34;)
        label = tk.Label(self, bg=&#39;light yellow&#39;, fg=&#39;black&#39;,
                         justify=tk.LEFT, text=Filter.help())
        label.pack()
        self.overrideredirect(True)
        self.grip.bind(&#34;&lt;ButtonPress-1&gt;&#34;, self.startMove)
        self.grip.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.stopMove)
        self.grip.bind(&#34;&lt;B1-Motion&gt;&#34;, self.onMotion)

    def startMove(self, event):
        &#34;&#34;&#34; Floating window dragging started
            Args:
                event: event.x and event.y hold the new position of the window
        &#34;&#34;&#34;
        self.x = event.x
        self.y = event.y

    def stopMove(self, _event):
        &#34;&#34;&#34; Floating window dragging stopped
            Args:
                _event: Not used but mandatory
        &#34;&#34;&#34;
        self.x = None
        self.y = None

    def onMotion(self, event):
        &#34;&#34;&#34; Floating window dragging ongoing
            Args:
                event: event.x and event.y hold the new position of the window
        &#34;&#34;&#34;
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.winfo_x() + deltax
        y = self.winfo_y() + deltay
        self.geometry(&#34;+%s+%s&#34; % (x, y))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Pollenisator.core.Application.Appli.FloatingHelpWindow.onMotion"><code class="name flex">
<span>def <span class="ident">onMotion</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Floating window dragging ongoing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>event.x and event.y hold the new position of the window</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMotion(self, event):
    &#34;&#34;&#34; Floating window dragging ongoing
        Args:
            event: event.x and event.y hold the new position of the window
    &#34;&#34;&#34;
    deltax = event.x - self.x
    deltay = event.y - self.y
    x = self.winfo_x() + deltax
    y = self.winfo_y() + deltay
    self.geometry(&#34;+%s+%s&#34; % (x, y))</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.FloatingHelpWindow.startMove"><code class="name flex">
<span>def <span class="ident">startMove</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Floating window dragging started</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>event.x and event.y hold the new position of the window</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startMove(self, event):
    &#34;&#34;&#34; Floating window dragging started
        Args:
            event: event.x and event.y hold the new position of the window
    &#34;&#34;&#34;
    self.x = event.x
    self.y = event.y</code></pre>
</details>
</dd>
<dt id="Pollenisator.core.Application.Appli.FloatingHelpWindow.stopMove"><code class="name flex">
<span>def <span class="ident">stopMove</span></span>(<span>self, _event)</span>
</code></dt>
<dd>
<div class="desc"><p>Floating window dragging stopped</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_event</code></strong></dt>
<dd>Not used but mandatory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopMove(self, _event):
    &#34;&#34;&#34; Floating window dragging stopped
        Args:
            _event: Not used but mandatory
    &#34;&#34;&#34;
    self.x = None
    self.y = None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Pollenisator.core.Application" href="index.html">Pollenisator.core.Application</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Pollenisator.core.Application.Appli.Appli" href="#Pollenisator.core.Application.Appli.Appli">Appli</a></code></h4>
<ul class="">
<li><code><a title="Pollenisator.core.Application.Appli.Appli.boundToMousewheel" href="#Pollenisator.core.Application.Appli.Appli.boundToMousewheel">boundToMousewheel</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.boundToMousewheelMain" href="#Pollenisator.core.Application.Appli.Appli.boundToMousewheelMain">boundToMousewheelMain</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.deleteACalendar" href="#Pollenisator.core.Application.Appli.Appli.deleteACalendar">deleteACalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.exportCalendar" href="#Pollenisator.core.Application.Appli.Appli.exportCalendar">exportCalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.exportCommands" href="#Pollenisator.core.Application.Appli.Appli.exportCommands">exportCommands</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.fixedMap" href="#Pollenisator.core.Application.Appli.Appli.fixedMap">fixedMap</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.getCentralizedFiles" href="#Pollenisator.core.Application.Appli.Appli.getCentralizedFiles">getCentralizedFiles</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.importCalendar" href="#Pollenisator.core.Application.Appli.Appli.importCalendar">importCalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.importCommands" href="#Pollenisator.core.Application.Appli.Appli.importCommands">importCommands</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initCommandsView" href="#Pollenisator.core.Application.Appli.Appli.initCommandsView">initCommandsView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initDashBoardView" href="#Pollenisator.core.Application.Appli.Appli.initDashBoardView">initDashBoardView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initMainView" href="#Pollenisator.core.Application.Appli.Appli.initMainView">initMainView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initReportView" href="#Pollenisator.core.Application.Appli.Appli.initReportView">initReportView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initScanView" href="#Pollenisator.core.Application.Appli.Appli.initScanView">initScanView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initSettingsView" href="#Pollenisator.core.Application.Appli.Appli.initSettingsView">initSettingsView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initSummaryView" href="#Pollenisator.core.Application.Appli.Appli.initSummaryView">initSummaryView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.initUI" href="#Pollenisator.core.Application.Appli.Appli.initUI">initUI</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.newCalendar" href="#Pollenisator.core.Application.Appli.Appli.newCalendar">newCalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.newSearch" href="#Pollenisator.core.Application.Appli.Appli.newSearch">newSearch</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.onClosing" href="#Pollenisator.core.Application.Appli.Appli.onClosing">onClosing</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.onExit" href="#Pollenisator.core.Application.Appli.Appli.onExit">onExit</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.openCalendar" href="#Pollenisator.core.Application.Appli.Appli.openCalendar">openCalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.prepareCalendar" href="#Pollenisator.core.Application.Appli.Appli.prepareCalendar">prepareCalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.promptCalendarName" href="#Pollenisator.core.Application.Appli.Appli.promptCalendarName">promptCalendarName</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.promptForConnection" href="#Pollenisator.core.Application.Appli.Appli.promptForConnection">promptForConnection</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.readNotifications" href="#Pollenisator.core.Application.Appli.Appli.readNotifications">readNotifications</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.refreshView" href="#Pollenisator.core.Application.Appli.Appli.refreshView">refreshView</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.removeFiles" href="#Pollenisator.core.Application.Appli.Appli.removeFiles">removeFiles</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.resetButtonClicked" href="#Pollenisator.core.Application.Appli.Appli.resetButtonClicked">resetButtonClicked</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.resetUnfinishedTools" href="#Pollenisator.core.Application.Appli.Appli.resetUnfinishedTools">resetUnfinishedTools</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.scrollFrameFunc" href="#Pollenisator.core.Application.Appli.Appli.scrollFrameFunc">scrollFrameFunc</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.scrollFrameMainFunc" href="#Pollenisator.core.Application.Appli.Appli.scrollFrameMainFunc">scrollFrameMainFunc</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.searchbarSelectAll" href="#Pollenisator.core.Application.Appli.Appli.searchbarSelectAll">searchbarSelectAll</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.selectNewCalendar" href="#Pollenisator.core.Application.Appli.Appli.selectNewCalendar">selectNewCalendar</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.setStyle" href="#Pollenisator.core.Application.Appli.Appli.setStyle">setStyle</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.showSearchHelp" href="#Pollenisator.core.Application.Appli.Appli.showSearchHelp">showSearchHelp</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.show_error" href="#Pollenisator.core.Application.Appli.Appli.show_error">show_error</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.statusbarClicked" href="#Pollenisator.core.Application.Appli.Appli.statusbarClicked">statusbarClicked</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.submitIssue" href="#Pollenisator.core.Application.Appli.Appli.submitIssue">submitIssue</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.tabSwitch" href="#Pollenisator.core.Application.Appli.Appli.tabSwitch">tabSwitch</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.unboundToMousewheel" href="#Pollenisator.core.Application.Appli.Appli.unboundToMousewheel">unboundToMousewheel</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.unboundToMousewheelMain" href="#Pollenisator.core.Application.Appli.Appli.unboundToMousewheelMain">unboundToMousewheelMain</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.Appli.wrapCopyDb" href="#Pollenisator.core.Application.Appli.Appli.wrapCopyDb">wrapCopyDb</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry" href="#Pollenisator.core.Application.Appli.AutocompleteEntry">AutocompleteEntry</a></code></h4>
<ul class="two-column">
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.changed" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.changed">changed</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.comparison" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.comparison">comparison</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.downArrow" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.downArrow">downArrow</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.quit" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.quit">quit</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.reset" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.reset">reset</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.selection" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.selection">selection</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.AutocompleteEntry.upArrow" href="#Pollenisator.core.Application.Appli.AutocompleteEntry.upArrow">upArrow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Pollenisator.core.Application.Appli.FloatingHelpWindow" href="#Pollenisator.core.Application.Appli.FloatingHelpWindow">FloatingHelpWindow</a></code></h4>
<ul class="">
<li><code><a title="Pollenisator.core.Application.Appli.FloatingHelpWindow.onMotion" href="#Pollenisator.core.Application.Appli.FloatingHelpWindow.onMotion">onMotion</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.FloatingHelpWindow.startMove" href="#Pollenisator.core.Application.Appli.FloatingHelpWindow.startMove">startMove</a></code></li>
<li><code><a title="Pollenisator.core.Application.Appli.FloatingHelpWindow.stopMove" href="#Pollenisator.core.Application.Appli.FloatingHelpWindow.stopMove">stopMove</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>